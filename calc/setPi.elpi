%%-- calc_setPi.elpi

type setPi mttType -> (mttTerm -> mttType) -> mttType.
type lambda mttType -> (mttTerm -> mttTerm) -> mttTerm.
type app mttTerm -> mttTerm -> mttTerm.



isType (setPi B C) KIND3 IE
    :- (isType B KIND1 IE)
    ,  (pi x\ locDecl x B
        => (isType (C x) KIND2 IE))
    ,  spy(pts_fun KIND1 KIND2 KIND3)
    .

of (lambda B F) (setPi B C) IE
    :- (isType B _ IE)
    ,  (pi x\ locDecl x B => isa (F x) (C x) IE)
    .

of (app Lam X) (CX) IE
    :- spy(of Lam (setPi B C) IE)
    ,  spy(isa X B IE)
    ,  CX = C X
    .


hstep (app LAM Bb) (F Bb)
    :- of LAM (setPi B C) IE
    ,  (isType B _ IE)
    ,  (isa Bb B IE)
    ,  hnf LAM (lambda B' F)
    ,  conv B B'
    ,  (pi x\ locDecl x B => isa (F x) (C x) IE)
    ,  (pi x\ locDecl x B => isType (C x) _ IE)
    .

dconv (setPi B C) (setPi B' C') 
    :- (conv B B')
    ,  (pi x\ locDecl x B => conv (C x) (C' x))
    .
dconv (app F X) (app F' X') :- (conv F F'), (conv X X').
dconv (lambda B F) (lambda B' F') 
    :- (conv B B')
    ,  pi x\  locDecl x B => (conv (F x) (F' x))
    .

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                   TRADUZIONE                                   %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



trad (setPi B C) T 
    :- spy(trad B Bi)
    ,  spy(pi x\ pi xi\ locDecl x B => locDecl xi Bi => trad x xi => trad (C x) (Ci xi))
    ,  spy(equ B EquB)
    ,  spy(pi x\ pi xi\ locDecl x B => locDecl xi Bi => trad x xi => equ (C x) (EquC xi))
    ,  spy(pi x1 \ pi x2 \ pi h\
        pi x1i\ pi x2i\ pi hi\ locDecl x1 B => locDecl x2 B
        => locDecl x1i Bi
        => locDecl x2i Bi
        => trad x1 x1i
        => trad x2 x2i
        => (locDecl h (propEq B x1 x2)) 
        => (locDecl hi (EquB x1i x2i))
        => trad h hi
        => spy(pippo (C x1) (C x2) (PippoC x1i x2i hi)))
    ,  T = colSigma (setPi Bi Ci) f\ (forall (Bi) x1\ (forall Bi x2\ (forall (EquB x1 x2) h\
    (
            EquC x2 
            (
                PippoC x1 x2 h (app f x1)
            ) 
            (app f x2)
    )
    )
    
    ) )
    .


trad (app F X) R 
    :- spy(of F (setPi B C) ext)
    ,  spy(trad_isa X B Xi)
    ,  spy(trad F Fi)
    ,  spy(of Fi T int)
    ,  spy(T = (colSigma PI _))
    ,  R = (app (elim_colSigma Fi (_\PI) (x\y\x) ) Xi)
    .


equ (setPi B C) P
    :- trad B Bi
    ,  (pi x\ pi xi\ locDecl x B => locDecl xi Bi => trad x xi => trad (C x) (Ci xi))
    ,  (pi x\pi xi\locDecl x B 
        => locDecl xi Bi
            => trad x xi
                => (trad (C x) (Ci x), equ (C x) (EquC x)))
    ,  P = (f\ g\ 
        forall Bi x\ 
            EquC x 
            (app (elim_colSigma f (_\setPi Bi Ci) (x\y\x) ) x) 
            (app (elim_colSigma g (_\setPi Bi Ci) (x\y\x) ) x))
    .

pippoequ (app F X1) (app F X2) T H 
    :- of F (setPi B T') ext
    ,  spy(pippoequ X1 X2 B G)
    ,  spy(trad F Fi)
    ,  spy(of Fi (colSigma TyF MorF) int)
    ,  PI1 = (c\ elim_colSigma c (_\ TyF) (x \ y\ x))
    ,  P2Fi = elim_colSigma Fi (c \ MorF (PI1 c)) (x\ y\ y)
    ,  spy(trad_isa X1 B X1i)
    ,  spy(trad_isa X2 B X2i)
    ,  pippo  (propEq (T' X2) (app F X1) (app F X2))
               (propEq (T) (app F X1) (app F X2)) PIPPO
    ,  H = PIPPO (forall_app (forall_app (forall_app P2Fi X1i) X2i) G)
    .

pippo (setPi B C) (setPi B' C') P
    :- (trad B' Bi')
    ,  (trad B Bi)
    ,  spy(pippo B' B FB)
    ,  spy(pi x\ pi x'\ pi xi\ pi xi'\ 
            locDecl x B => locDecl xi Bi => trad x xi
            locDecl x' B' => locDecl xi' Bi' => trad x' xi'
            => pippo (C x) (C' x') (FC xi xi'))
    ,  ( pi x\ pi xi\ locDecl x B => locDecl xi Bi => trad x xi => trad (C x) (Ci xi))
    ,  (trad (setPi B' C') (colSigma T1 T2)), T1 = setPi Bi' Ci'
    ,  P = f\ pair T1 T2
        (lambda Bi' x\ FC (FB x) x (app (elim_colSigma f (_\setPi Bi Ci) (x\y\x) ) (FB x)))
        (fixMe "prova eta setPi preserva uguaglianza")
    .