%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                              Dependent Products                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                    CALCOLO                                    %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


ofType (setPi B C) KIND3 IE
    :- (ofType B KIND1 IE)
    ,  (pi x\ locDecl x B
        => (ofType (C x) KIND2 IE))
    ,  spy(pts_fun KIND1 KIND2 KIND3)
    .

of (lambda B F) (setPi B C) IE
    :- spy (ofType B _ IE)
    ,  spy (pi x\ locDecl x B => isa (F x) (C x) IE)
    .

of (app Lam X) (CX) IE
    :- spy(of Lam (setPi B C) IE)
    ,  spy(isa X B IE)
    ,  CX = C X
    .


hstep (app LAM Bb) (F Bb)
    :- of LAM (setPi B C) IE
    ,  (ofType B _ IE)
    ,  (isa Bb B IE)
    ,  hnf LAM (lambda B' F)
    ,  conv B B'
    ,  (pi x\ locDecl x B => isa (F x) (C x) IE)
    ,  (pi x\ locDecl x B => ofType (C x) _ IE)
    .

dconv (setPi B C) (setPi B' C') 
    :- (conv B B')
    ,  (pi x\ locDecl x B => conv (C x) (C' x))
    .
dconv (app F X) (app F' X') :- (conv F F'), (conv X X').
dconv (lambda B F) (lambda B' F') 
    :- (conv B B')
    
    %This was the previous conversion rule for lambda abstractions
    ,  pi x\  locDecl x B => (conv (F x) (F' x)) 
    %,  ( pi x\ (conv (F x) (F' x))
    %   ; F = F'
    %   )
    .
    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                   TRADUZIONE                                   %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



interp (setPi B C) T 
    :- nodebug => (macro_interp B x\xi\_\_\ interp (C x) (Ci xi))
    ,  nodebug => (macro_interp B x\xi\_\_\ setoid_eq (C x) (EquC xi))
    ,  nodebug => spy(interp B Bi)
    ,  nodebug => spy(setoid_eq B EquB)
    ,  macro_Pi B (x1\x2\h\x1i\x2i\hi\ tau (C x1) (C x2) (PippoC x1i x2i hi))
    ,  T = setSigma (setPi Bi Ci) 
        f\ forall Bi 
         x1i\ forall Bi 
          x2i\ forall (EquB x1i x2i) 
           h\ EquC x2 (PippoC x1i x2i h (app f x1i)) (app f x2i)
    .






interp (app F X) R 
    :- spy(of F (setPi B C) ext)
    ,  spy(interp_isa X B Xi)
    ,  spy(interp F Fi)
    ,  spy(of Fi T int)
    ,  spy(T = (setSigma PI _))
    ,  R = (app (elim_setSigma Fi (_\PI) (x\y\x) ) Xi)
    .


interp (lambda B F) R                
    :- spy(of (lambda B F) (setPi B C) ext)
    ,  spy(interp (setPi B C) (setSigma (setPi Bi Ci) H ))
    ,  spy(macro_tau B B ( x\_\_\xi\_\_\ interp (F x) (Fi xi)))
    ,  spy(setoid_eq B EquB)
    ,  spy(macro_tau B B (x1\x2\h\x1i\x2i\hi\tau_proof_eq (F x1) (F x2) (C x2) (K_EQU x1i x2i hi)))
    ,  spy(R = pair (setPi Bi Ci) (H) (lambda Bi Fi)
        (forall_lam Bi x1\ forall_lam Bi x2\ forall_lam (EquB x1 x2) h\
            K_EQU x1 x2 h))
    .


setoid_eq (setPi B C) P
    :- spy(interp B Bi)
    ,  spy(pi x\ pi xi\ locDecl x B => locDecl xi Bi => interp x xi => interp (C x) (Ci xi))
    ,  spy(pi x\ pi xi\locDecl x B 
        => locDecl xi Bi
            => interp x xi
                => (interp (C x) (Ci xi), setoid_eq (C x) (EquC xi)))
    ,  P = (f\ g\ 
        forall Bi x\ 
            EquC x 
            (app (elim_setSigma f (_\setPi Bi Ci) (x\y\x) ) x) 
            (app (elim_setSigma g (_\setPi Bi Ci) (x\y\x) ) x))
    .

tau_proof_eq (app F X1) (app F X2) T H 
    :- of F (setPi B T') ext
    ,  spy(tau_proof_eq X1 X2 B G)
    ,  spy(interp F Fi)
    ,  spy(of Fi (setSigma TyF MorF) int)
    ,  PI1 = (c\ elim_setSigma c (_\ TyF) (x \ y\ x))
    ,  P2Fi = elim_setSigma Fi (c \ MorF (PI1 c)) (x\ y\ y)
    ,  spy(interp_isa X1 B X1i)
    ,  spy(interp_isa X2 B X2i)
    ,  spy(tau (propEq (T' X2) (app F X1) (app F X2))
               (propEq (T) (app F X1) (app F X2)) PIPPO)
    ,  H = PIPPO (forall_app (forall_app (forall_app P2Fi X1i) X2i) G)
    . 

% tau_proof_eq (lambda B F) (lambda B' F') T H :- TODO.

tau (setPi B C) (setPi B' C') P
    :- spy(interp (setPi B C) (setSigma T1 T2))
    ,  spy(T1 = setPi Bi Ci)
    ,  spy(interp (setPi B' C') (setSigma T1' T2'))
    ,  spy(T1' = setPi Bi' Ci')
    ,  spy(setoid_eq B' EquB')
    %,  spy(macro_tau B B (_\x2\_\_\x2i\hi\ setoid_eq (C x2) (EquC x2i)))
    ,  spy(tau B' B FB)
    ,  spy(macro_tau B B' 
        (x\x'\h\xi\xi'\hi\ tau (C x) (C' x') (FC' xi xi' hi)))
    ,  spy(macro_tau B B (x1\x2\_\x1i\x2i\hi\ tau (C x1) (C x2) (FCC x1i x2i hi)))
    ,  spy(tau_trasp B' B KB)
    ,  spy(macro_tau B B' x\x'\_\xi\xi'\hi\ tau_trasp (C x) (C' x') (KC' xi xi' hi))
    ,  spy(setoid_refl B Hi)
    ,  spy(pi y1'\ pi y2'\ pi d'\ 
        locDecl y1' Bi' =>
            locDecl y2' Bi' =>
                locDecl d' (EquB y1' y2') =>
                    tau_trasp B' B (FH y1' y2' d'))
    ,  spy(P = 
        (w\ elim_setSigma w (_\setSigma T1' T2')
            f\p\ pair T1' T2'
                (lambda Bi' x\ FC' (FB x) x (Hi x) (app f (FB x)))
                (forall_lam Bi' y1'\ forall_lam Bi' y2'\ forall_lam (EquB' y1' y2') d'\
                    KC' (FB y2') 
                        y2' 
                        d' 
                        (FCC (FB y1') (FB y2') (FH y1' y2' d') (app f (FB y1')))
                        (app f (FB y2'))
                        (forall_app
                          (forall_app
                            (forall_app p (FB y1'))
                            (FB y2'))
                          (KB y1' y2' d')
                         )
                )
        ) )
    . 

tau_trasp (setPi B C) (setPi B' C') P 
    :- spy(macro_tau B B' x\x'\_\xi\xi'\hi\ tau_trasp (C x) (C' x') (KC' xi xi' hi))
    ,  spy(tau B' B FB)
    ,  P = f\g\d\ forall_lam B' y'\ 
            KC' (FB y') 
                y'
                d
                (app f (FB y'))
                (app g (FB y'))
                (forall_app d (FB y'))
                
    .
 

setoid_refl (setPi B C) H 
    :- spy(interp (setPi B C) SetPiBCi)
    ,  interp B Bi
    ,  (pi y\ pi yi\ locDecl y B => locDecl yi Bi => interp y yi => interp (C y) (Ci yi))
    ,  spy(pi y\ pi yi\ locDecl y B => locDecl yi Bi => interp y yi => setoid_refl (C y) (HC yi))
    ,  spy(
        H = z\ forall_lam Bi y\ (HC y (app (elim_setSigma z (z\setPi Bi Ci) a\b\a) y) )
    )
    ,  spy(setoid_eq (setPi B C) EquBC)
    ,  (pi z\ TypeH z = EquBC z z)
    ,  spy( pi z\ locDecl z SetPiBCi =>
        spy(of (H z) (TypeH z) int)
    )
    .

setoid_symm (setPi B C) H 
    :- spy(interp (setPi B C) SetPiBCi)
    ,  spy(setoid_eq (setPi B C) EquBC)
    ,  interp B Bi
    ,  (pi y\ pi yi\ locDecl y B => locDecl yi Bi => interp y yi => interp (C y) (Ci yi))
    ,  spy(pi y\ pi yi\ locDecl y B => locDecl yi Bi => interp y yi => setoid_symm (C y) (HC yi))
    ,  spy(
        H = f\g\h\ forall_lam Bi 
         yi\ HC yi 
          (app (elim_setSigma f (z\setPi Bi Ci) a\b\a) yi) 
          (app (elim_setSigma g (z\setPi Bi Ci) a\b\a) yi) 
          (forall_app h yi)
    )
    ,  spy(
        pi f\ pi g\ locDecl f SetPiBCi => locDecl g SetPiBCi => pi h\ locDecl h (EquBC f g) =>
            spy(
                of (H f g h) (EquBC g f) int
            )
    )
    .
setoid_tran (setPi B C) H 
    :- spy(interp (setPi B C) SetPiBCi)
    ,  spy(setoid_eq (setPi B C) EquBC)
    ,  interp B Bi
    ,  (pi y\ pi yi\ locDecl y B => locDecl yi Bi => interp y yi => interp (C y) (Ci yi))
    ,  spy(pi y\ pi yi\ locDecl y B => locDecl yi Bi => interp y yi => 
        setoid_tran (C y) (HC yi))
    ,  spy(
        H = f\g\h\p\q\ forall_lam Bi yi\ 
            HC yi 
            (app (elim_setSigma f (z\setPi Bi Ci) a\b\a) yi)
            (app (elim_setSigma g (z\setPi Bi Ci) a\b\a) yi)
            (app (elim_setSigma h (z\setPi Bi Ci) a\b\a) yi)
            (forall_app p yi)
            (forall_app q yi)
    )
    .