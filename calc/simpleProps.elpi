%%-- calc_simpleProps.elpi

%%%%Disjuntion

isType (or A B) prop :- isType A prop, isType B prop.
isType (or A B) props :- isType A props, isType B props.


of (or_r A B BB) (or A B) int :-  
        isType A prop, 
        isType B prop, 
        isa BB B int.

of (or_l A B AA) (or A B) int :-  
        isType A prop , 
        isType B prop , 
        isa AA A int.
        

of (elim_or W C Cl Cr) (C W) int :- 
    of W (or A B) int,
    isType C prop,
    (pi x\ of x A int => of (Cl x) C int),
    (pi y\ of y B int => of (Cr y) C int).

hstep (elim_or (or_l A B Wl) C Cl Cr) (Cl Wl).
hstep (elim_or (or_r A B Wr) C Cl Cr) (Cr Wr).

dstep (elim_or W C Cl Cr) (elim_or W' C Cl Cr) :- dstep W W'.

dstep (elim_or W C Cl Cr) (elim_or W C Cl' Cr) :- 
    pi w\ of w (or A B) int => dstep (Cl w) (Cl' w).

dstep (elim_or W C Cl Cr) (elim_or W C Cl Cr') :- 
    pi w\ of w (or A B) int => dstep (Cr w) (Cr' w)  

dstep (elim_or W C Cl Cr) (elim_or W C' Cl Cr) :- 
    pi w\ of w (or A B) int => dstep (C w) (C' w)  


dstep (or_l A B AA) (or_l A B AA') :- dstep AA AA'.
dstep (or_r A B BB) (or_r A B BB') :- dstep BB BB'.

dstep (or A B) (or A' B) :- dstep A A'.
dstep (or A B) (or A B') :- dstep B B'.

%-----------------------------------%
of true (or B C) ext :- isType B prop, isType C prop, of true B ext.
of true (or B C) ext :- isType B prop, isType C prop, of true C ext.
%of true D ext :- isType D prop, of true (or B C) ext,
%    (pi x\ of x B ext => of true D ext),
%    (pi x\ of x C ext => of true D ext).

%%% Conjuntion


isType (and B C) prop :-
    isType B prop,
    isType C prop.
isType (and B C) props :-
    isType B props,
    isType C props.

of (and_p B C BB CC) (and B C) int :-  
    isa BB B int, 
    isa CC C int,
    isType B prop,
    isType C prop.
    
hstep (p1 Pair) BB :-
        hnf Pair (and_p B C BB CC).

hstep (p2 Pair) CC :-
        hnf Pair (and_p B C BB CC).

dstep (and B1 C) (and B2 C) :- dstep B1 B2.
dstep (and B C2) (and B C2) :- dstep C1 C2.

dstep (and_p B1 C Bb Cc) (and_p B2 C Bb Cc) :- dstep B1 B2.

dstep (and_p B C1 Bb Cc) (and_p B C2 Bb Cc) :- dstep C1 C2.

dstep (and_p B C Bb1 Cc) (and_p B C Bb2 Cc) :- dstep Bb1 Bb2.

dstep (and_p B C Bb Cc1) (and_p B C Bb Cc2) :- dstep Cc1 Cc2.

dstep (and A B) (and A' B) :- dstep A A'.
dstep (and A B) (and A B') :- dstep B B'.

%-------------------%
of true (and B C) ext :- 
    isType B prop,
    isType C prop,
    of true B ext,
    of true C ext.

%of true B ext :-
%    isType (and B C) prop,
%    of true (and B C) ext.

%of true C ext :-
%    isType (and B C) prop,
%    of true (and B C) ext.

%%%% Implication

isType (implies B C) prop :- isType B prop, isType C prop.
isType (implies B C) props :- isType B props, isType C props.

of (lam_impl B CC) (implies B C) int :- 
    isType B prop, 
    (pi x\ of x B int => of (CC x) C int),
    isType C prop.
    
of (app_impl F BB) C int :- 
        hnf F (lam_impl B CC),
        isa BB B int,
        (pi x\ of x B int => of (CC x) C int).

hstep (app_impl (lam_impl B CC) BB) (CC BB) :-
        isa BB B int, 
        isType B prop,
        (pi x\ of x B int => of (CC x) C int),
        isType C prop.
        
dstep (app_impl F BB1) (app_impl F BB2) :- dstep BB1 BB2.       

dstep (app_impl F1 BB) (app_impl F2 BB) :-
    hnf F1 (lam_impl B CC),
    pi x\ of x B int => dstep (F1 x) (F2 x).
     

dstep (implies A B) (implies A' B) :- dstep A A'.
dstep (implies A B) (implies A B') :- dstep B B'.
%-----------------------%
of true (implies B C) ext :- 
    isType B prop,
    isType C prop,
    (pi x\ of x B ext => of true C ext).

%Questa regola diverge
of true C ext :-
    printW "-------" C,
    of true (implies B C) ext,  
    of true B ext,
    isType C prop,
    isType B prop.

%%%forall

isType  (forall B C) prop :- 
    isType B col,
    (pi x\ of x B int => isType (C x) prop).

isType  (forall B C) props :- 
    isType B set,
    (pi x\ of x B int => isType (C x) props).

of (lam_for B CC) (forall B C) int :- 
        isType B prop,
        (pi x\ of x B int => of (CC x) (C x) int)
        (pi x\ of x B int => isType  (C x) prop).

of (app_for F BB) (C BB) int :- 
        hnf F (lam_for B CC),
        isa BB B int,
        (pi x\ of x B int => of (CC x) (C x) int).

hstep (app_for F BB) (CC BB) :-
        hnf F (lam_for B CC),
        isa BB B int,
        (pi x\ of x B int => of (CC x) (C x) int).
        
dstep (app_for F BB) (app_for F' BB') :- dstep F F'.
dstep (app_for F BB) (app_for F' BB') :- dstep BB BB'. 

dstep (lam_for B CC) (lam_for B' CC') :- dstep B B'.
dstep (lam_for B CC) (lam_for B' CC') :- 
        pi x\ of x B int => dstep (CC x) (CC' x).



dstep (forall A B) (forall A' B) :- dstep A A'.
dstep (forall A B) (forall A B') :- 
    pi x\ of x A int => dstep (B x) (B' x).

%---------------------------------%

of true (forall B C) ext :- 
    (pi x\ of x B ext => of true (C x) ext),
    (pi x\ of x B ext => isType (C x) prop).

% Credo non ci sia modo di non far divergere questa regola 
%of true (C BB) ext :-
%    of BB B ext,
%    of true (forall B C) ext.
%    


%%%Exist

isType (exist B C) prop :- 
    isType B col,
    (pi x\ of x B int => isType (C x) prop).
isType (exist B C) props :- 
    isType B set,
    (pi x\ of x B int => isType (C x) props).

of (exist_p B C BB CC) (exist B C) int :- 
        isType B col,
        of BB B int,
        of CC (C BB) int,
        (pi x\ of x B int => isType (C x) prop).


of (elim_exist Pair M MM) M int :-
        of Pair (exist B C) int,
        isType M prop,
        (pi x \ pi y \
            of x B int => of y (C x) int =>  
                of (MM x y) M int ).

hstep (elim_exist (pair B C Bb Cc) M Mm) (Mm Bb Cc) :-
    of Bb B int,
    of Cc (C Bb) int,
    (pi x \ pi y \
        of x B int => of y (C x) int =>  
            of (Mm x y) M  int).
        
dstep (exist_p B C BB CC) (exist_p B' C BB CC) :- dstep B B'.
dstep (exist_p B C BB CC) (exist_p B C' BB CC) :- (pi x\ of x B int => dstep (C x) (C' x)).
dstep (exist_p B C BB CC) (exist_p B C BB' CC) :- dstep BB BB'.
dstep (exist_p B C BB CC) (exist_p B C BB CC') :- dstep CC CC'.

dstep (elim_exist Pair M MM) (elim_exist Pair' M MM) :- dstep Pair Pair'.

dstep (elim_exist Pair M MM) (elim_exist Pair M MM') :- 
    of Pair (exist B C) int,
    pi x\ pi y\ of x B int => of y (C x) int => dstep (MM x y) (MM' x y).

dstep (elim_exist Pair M MM) (elim_exist Pair M' MM) :- dstep M M'.


dstep (exist A B) (exist A' B) :- dstep A A'.
dstep (exist A B) (exist A B') :- 
    pi x\ of x A int => dstep (B x) (B' x).



%------------------------------%
of true (exist B C) ext :-
    isType B col,
    (pi x\ of x B ext => isType (C x) prop) 
    of BB B ext,
    of true (C BB) ext.

%of true M ext :-
%    isType M prop,
%    of true (exist B C) ext,
%    (pi x\ pi y\
%        of x B ext => of y (C x) ext =>
%            of true M ext).






%%%%Falsum
 
isType bottom props.
of (r0 F A) A int :- isType A prop, of F bottom int.

%----------------------%

of true A ext :- isType A prop, of true bottom ext.


