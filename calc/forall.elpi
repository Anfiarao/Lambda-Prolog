%%-- calc_setPi.elpi

type forall     mttType -> (mttTerm -> mttType) -> mttType.
type forall_lam mttType -> (mttTerm -> mttTerm) -> mttTerm.
type forall_app mttTerm -> mttTerm -> mttTerm.

isType (forall B C) KIND3 IE :-
spy    (isType B KIND IE), 
spy    (pi x\ locDecl x B  => spy(isType (C x) KIND' IE)),
spy    (pts_for KIND KIND' KIND3).

of (forall_lam B F) (forall B C) IE :-
        (isType B _ IE),
        (pi x\ locDecl x B => isa (F x) (C x) IE).

of (forall_app Lam X) (C X) IE :- 
        isa (Lam) (forall B C) IE,
        isa X B IE. 


hstep (forall_app LAM Bb) (F Bb) :- 
        hnf LAM (forall_lam B F),
        isType B _ IE,
        isa Bb B IE,
        (pi x\ locDecl x B => isa (F x) (C x) IE ),
        (pi x\ locDecl x B => isType (C x) KIND IE ).

dconv (forall B C) (forall B' C') :- 
        (conv B B'), 
        (pi x\ locDecl x B => conv (C x) (C' x)).
dconv (forall_app F X) (forall_app F' X') :- (conv F F'), (conv X X').
dconv (forall_lam B F) (forall_lam B' F') :- (conv B B'), 
        pi x\ locDecl x B =>
                %locDecl x' B' =>
                %hstep x x'    => 
                (conv (F x) (F' x)).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

trad (forall B C) (forall B' C') :-
        spy (trad B B'),
        spy (pi x\ pi x' \ trad x x' => locDecl x B => locDecl x' B' => trad (C x )(C'  x')).

trad singleton singleton.
trad star star.

trad (implies B C) (forall B' C') :-
        trad B B',
        spy(pi x\ pi x'\ (trad x x', locDecl x B, locDecl x' B') => trad C (C' x')) .


trad (propEq A Aa1 Aa2) R :-
        spy(equ  A EquA),
        spy(trad Aa1 Aa1'),
        spy (trad Aa2 Aa2'),
        spy(R = (EquA Aa1' Aa2')).

trad (eqId  A Aa)  (ReflA Aa') :-
        reflu A ReflA,
        trad Aa Aa'.

trad (fun B C) R :-
        spy(trad B B') ,
        spy(trad C C') ,
        spy(equ B EquB) ,
        equ C EquC,
        R = (colSigma (fun B' C') h\ forall B' y1\ forall B' y2\ 
        forall (EquB y1 y2) d\ EquC (fun_app h y1 ) (fun_app h y2))
        .
trad (fun_app F X) R :-
        spy(of F (fun B C) ext),
        spy(of X B2 ext),
        spy(pippo B2 B PIPPO),
        spy(trad X X'),
        spy(trad F F'),
        spy( of F' T int),
        spy(T = (colSigma B' _)),
        R = (fun_app (elim_colSigma F' (_\B') (x\y\x) ) (PIPPO X')).

equ singleton (x\ y\ propId singleton x y).
reflu singleton (x\ id singleton x).

equ (propEq A Aa1 Aa2) (_\ _\ (propId singleton star star)).

 
pippo (propEq T T1 T2) (propEq T T1' T2') (F) :- 
        spy(pippoequ T1 T1' F1),
        spy(pippoequ T2 T2' F2),
        spy(trad T1 T1i),
        spy(trad T2 T2i),
        spy(trad T1' T1i'),
        spy(trad T2' T2i'),
        spy(trad T Ti),
        F = x\ impl_app ( 
                impl_app ( 
                 forall_app ( 
                  forall_app ( 
                   impl_app ( 
                    forall_app ( 
                     forall_app (k_propId Ti) T1i) T1i') F1) T2i) T2i') F2)  x.
 
% supponiamo che conv X Y per poter usare pippoequ X Y H
%       H Ã¨ la prova che i tradotti siano uguali nel loro setoide
% RINOMINARE pippoequ in tradConv
pippoequ A A (id T' A' ) :-
        trad A A',
        of A' T' int.
pippoequ A B H' :-
        spy(locDecl H (propEq _ A B)),
        trad H H'.

pippoequ (fun_app F X1) (fun_app F X2) H :-
        pippoequ X1 X2 G,
        trad F F',
        P2F' = elim_colSigma F' _ (x\ y\ y),
        trad X1 X1',
        trad X2 X2',
        H = forall_app (forall_app (forall_app P2F' X1') X2') G. 




locDecl (k_propId T) (forall T t1\ forall T t1'\ 
        implies (propId T t1 t1') (forall T t2\ forall T t2'\ 
                implies (propId T t2 t2') (implies (propId T t1 t2) (propId T t1' t2'))) ).


