%%-- united.elpi

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%-- calc_singleton.elpi

% SINGLETON SET

isType singleton set.

of star singleton IE.

of (elim_singleton T C CC) (C T) IE :- 
    of T singleton IE,
    of CC (C star) IE,
    (pi z\ locDecl z singleton => isType (C z) col).

hstep (elim_singleton star C CC) CC :- 
        of CC (C star) IE,
        (pi z\ locDecl z singleton => isType (C z) col ).

dstep (elim_singleton T C CC) (elim_singleton T' C CC) :- dstep T T'.
dstep (elim_singleton T C CC) (elim_singleton T C CC') :- dstep CC CC'.
dstep (elim_singleton T C CC) (elim_singleton T C' CC) :- 
        (pi z\ locDecl z singleton => dstep (C z) (C' z)).

sigm singleton singleton DIR.
sigm W W DIR :- of W singleton int.

%equ singleton X Y (propId(singleton, star star)) .
%equ singleton (x \ y \ id singleton x y).

trad singleton singleton.
trad star star.

trad (elim_singleton T C CC) (elim_singleton T' C' CC') :-
 tau' singleton T T',
% printW "1" T',
% printW "1" T,
% printW "1" C,
% printW "1" CC,
 (pi xe \ pi xi \ 
    trad xe xi => 
    locDecl xi singleton => 
    locDecl xe singleton =>
    ( 
     trad (C xe) (C' xi),
%     printW "2: " C',
     tau' (C star) CC CC'
    ) 
 ).

tau singleton singleton star star.
sigm DIR X X :- of X singleton int.

%prove_eq (elim_singleton T1 C1) (elim_singleton T2 C2) P :-
% pi x \ prove_eq x x => prove_eq (C1 x) (C2 x).

%prove_eq star star (refl singleton star).

equ singleton X1 X2 (propId singleton X1 X2).



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%-- calc_empty.elpi

isType empty set.

of (emp Z A) (A Z) IE 
   :- of Z empty IE
    , (pi x\ locDecl x empty => isType (A x) _)
    .

of bottom empty IE.


tau empty empty A A.

trad bottom bottom.
trad empty empty.
trad (emp X A) (emp X' A') 
   :- tau' empty X X'
    , (pi xe\ pi xi\ of xe empty ext
                     => of xi empty int 
                     => trad xe xi 
                     => trad (A xe) (A' xi))
    .

sigm Z Z :- of Z empty int.    


equ empty X1 X2 (propId empty X1 X2).
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%-- calc_colSigma.elpi

%% STRONG INDEXED COL SUM

isType (colSigma B C) col :-
    isType B col,
    pi b\ locDecl b B => isType (C b) col.

of (pair B C BB CC) (colSigma B C) int :-
    isType B col,
    isType (C BB) col,
    of BB B int,
    of CC (C BB) int,
    isType (colSigma B C) col.

of (elim_colSigma Pair M MM) (M Pair) int :-
        of Pair (colSigma B C) int,
        (pi z \ locDecl z (colSigma B C) => isType (M z) col),
        (pi x \ pi y \
            locDecl x B => of y (C x) int =>  
                of (MM x y) (M (pair B C x y)) int ).

hstep (elim_colSigma (pair B C Bb Cc) M Mm) (Mm Bb Cc) :-
    of Bb B int,
    of Cc (C Bb) int,
    (pi z\ locDecl z (colSigma B C) => isType (M z) col),
    (pi x \ pi y \
        locDecl x B => of y (C x) int =>  
            of (Mm x y) (M (pair B C x y))  int
    ).


dstep (pair B1 C Bb Cc) (pair B2 C Bb Cc) :- dstep B1 B2.

dstep (pair B C1 Bb Cc) (pair B C2 Bb Cc) :- 
    pi b\ locDecl b B => dstep (C1 b) (C2 b).

dstep (pair B C Bb1 Cc) (pair B C Bb2 Cc) :- dstep Bb1 Bb2.

dstep (pair B C Bb Cc1) (pair B C Bb Cc2) :- dstep Cc1 Cc2.


dstep (elim_colSigma Pair1 M Mm) (elim_colSigma Pair2 M Mm) :- 
    dstep Pair1 Pair2.

dstep (elim_colSigma Pair M Mm1) (elim_colSigma Pair M Mm2) :-
    of Pair (colSigma B C) int, 
    pi x\ pi y\ locDecl x B => of y (C x) => dstep (Mm1 x y) (Mm2 x y).

dstep (elim_colSigma Pair M1 Mm) (elim_colSigma Pair M2 Mm) :-
        of Pair Ty int, 
        pi z\ of z Ty int => dstep (M1 z) (M2 z).

dstep (colSigma B C) (colSigma B' C) :- dstep B B'.
dstep (colSigma B C) (colSigma B C') :- (pi x\ of x B int => dstep (C x) (C' x)).








%%colSigma

trad (colSigma B C) (colSigma Bi Ci) :- 
        trad B Bi, 
        spy ( pi xe\ pi xi\ 
            trad xe xi => 
            of xe B ext =>
            of xi Bi int =>
            trad (C xe) (Ci xi) ).

trad (pair B C Bb Cc) (pair Bi Ci Bib Cic) :-
        trad B Bi,
        (pi xe\ pi xi\ 
            trad xe xi => 
            of xe B ext =>
            of xi Bi int => trad (C xe) (Ci xi) 
        ),
        tau' B Bb Bib,
        (pi xe\ pi xi\ 
            trad xe xi => 
            of xe B ext =>
            of xi Bi int => tau' (C xe) Cc Cic  
        ).

sigm DIR W W' :- 
        of W (colSigma B C) int,
        sigm DIR B B',
        (pi x\ pi x'\ 
            of x B int =>
            of x' B' int =>
            sigm DIR x x' =>
            sigm DIR (C x) (C' x')
        ),
        (pi x\
            of x B int =>
            sigm DIR x (F1 x)
        ),
        (pi x\ pi y\
            of x B int =>
            of y (C x) int => 
            sigm DIR x (F1 x) =>
            sigm DIR y (F2 y)
        ),
        W' = (elim_colSigma 
                (W) 
                (colSigma B' C') 
                (w1\ w2\ pair B' C' (F1 w1) (F2 w2) )
             )
        .

%bnf (
%     equ (colSigma B C) Z1 Z2
%    ) 
%    (
%     exist (equ B (p1 Z1) (p1 Z2)
%           ) 
%           (d\
%            subst (p1 Z1) 
%                  (p1 Z2) 
%                  (equ (C (p1 Z2)) (p2 Z1) (p2 Z2))
%           ) 
%    ) :-  of Z1 colSigma B C, of Z2 colSigma B C.

%:- of Z1 (colSigma B C), of Z2 (colSigma B C).

%trad (pair BB CC Bb Cc) (pair (trad BB) (trad CC) (trad Bb) (trad Cc)).

%subst X1 X2 wimSigma




%trad (quotientCol A R ) Ai :- trad A Ai.

%bnf (equ (quotientCol A R) Z1 Z2) (R Z1 Z2) :- of Z1 A, of Z2 A.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%-- calc_setPi.elpi

isType set (setPi B C) :-
    isType set B, 
    pi x\ of x B int => isType (C x) set.

of (lam B CC) (setPi B C) int :-
        isType B int,
        pi x\ of x B int => of (CC x) (C x) int.

of (app Lam X) (C X) int :-
        hnf Lam (lam B CC),
        of (lam B CC) (setPi B C) int,
        isa X B int. 


hstep (app LAM BB) (CC BB) :- 
        hnf LAM (lambda B CC),
        isType B set,
        isa BB B int,
        (pi x\ of x B int => of (CC x) (C x) int ),
        (pi x\ of x B int => isType (C x) set ).

dstep (lambda B1 F) (lambda B2 F) :- dstep B1 B2.

dstep (lambda B F1) (lambda B F2) :- 
        pi b\ of b B int => dstep (F1 b) (F2 b).

dstep (app L X1) (app L X2) :- dstep X1 X2.
dstep (app L1 X) (app L2 X) :- dstep L1 L2.






%%% DEPENDENT PRODUCT SET

%trad 
%    (setPi B C) 
%    (colSigma 
%        (setPi TradB TradC)
%        (H\
%            (forall TradB y1\
%                (forall TradB y2\
%                    (forall (EQUB y1 y2) d \
%                        (EQUC y2 (SIGMA y1 y2 (app H y1)) (app H y2)
%                        )
%                    )
%                )
%            )
%        )
%    )
%    :- trad B TradB ,
%    (pi ye\ 
%         pi yi\ trad ye yi 
%             => of ye B ext 
%             => of yi TradB int
%             => trad (C ye) (TradC1 yi)) 
%    equ TradB EQUB,
%    (pi y \ equ (TradC y) (EQUC y)),
%    (pi y1 \ pi y2 \ pi z \ sigma y1 y2 => sigm z (SIGMA z)).

%trad (lambda B Cc) (pair (lambda TradB TradCc) P )
%    :- trad B TradB,
%       (of  
%            (lambda B Cc) 
%            (setPi B T_inferred_ext)
%            ext),
%       (pi x \ trad x x => 
%        trad (Cc x) (TradCc x), of (TradCc x) (T_inferred x),
%         trad (T_inferred_ext x) (T_inferred_ext_trad x),
%         tau (T_inferred x) (T_inferred_ext_trad x) (TAU x)),
%       equ TradB EQU,
%       (pi x1 \ pi x2 \ pi d \ prove_equ x1 x2 d => sigma x1 x2 =>
%         sigma (TradCc x1) UUU,
%         prove_equ UUU (TradCC x2) PROVEEQ),
%       P = lambda TradB x1 \ lambda TradB x2 \ lambda (EQU x1 x2) d \
%            PROVEEQ x1 x2 d.


%%equ (setPi B C) something.

%% ££££££££££££££ TODO ££££££££££££££££££££

%% £££££££ sigm A B =====> sigm DIR A B

%sigm DIR A B :- hsigm DIR A B.
%sigm DIR A B :- dir_inv DIR INVDIR, hsigm INVDIR B A.

%dir_inv forward backward.
%dir_inv backward forward.

%sigm DIR W W' :-
% of int W (colSigma (setPi BI CI) _),
% print "TIPAGGIO \n\n",
% sigm DIR BI BI',
% print "step2\n\n",
% (pi x \ of int x BI => sigm DIR (CI x) (CI' x)),
% print "step3\n",
% (pi a \ pi b \ of int a BI => of int b BI => equ BI' a b (EQBI' a b)),
% print "qweqwe\n",
% (pi x2 \ pi a \ pi b \ of int x2 BI' => of int a (CI' x2) => of int b (CI' x2) =>
%   equ (CI' x2) a b (EQCI'x2 x2 a b)),
% print "qweqwe2\n",
% (pi x1 \ pi x2 \ pi x \ of int x2 BI' => of int x1 BI' hsigm DIR x1 x2 => of int x (CI' x1) => sigm DIR x (SIGfx1 x1 x2 x)), 
% print "qweqwe3\n",
% 
% W' = pair (setPi BI' CI')
%  (f \ forall BI' x1 \ forall BI' x2\
%    implies (EQBI' x1 x2) (EQCI'x2 x2 (SIGfx1 x1 x2 (app f x1)) (app f x2)))
%  F' P',
% 
% macro (fst W) F,
% macro (snd W) P,
% print "SIGMI!!",
% dir_inv INV INVDIR,
% (pi y \ of int y BI' => sigm INVDIR (INVSIG y) y),
% print "QWEQWEQWE 4\n\n",
% (pi y \ pi x \ of int y BI' => of int x (CI (INVSIG y)) => hsigm DIR (INVSIG y) y => sigm DIR x (SIG2 x)),
% print "QWEQWEQWQWEQWE\n",
% F' = (lam BI' y \ SIG2 (F (INVSIG y))),
% P' = delirio_assoluto.


%testxxx W' :-
% W = pair (setPi singleton x \ singleton) (x\singleton) (lam singleton x \ x) star,
% sigm forward W W'.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%-- calc_setSum.elpi

%%Disjoint Sum Type

isType (setSum A B) set :- isType A set, isType B set.

of (inr A B BB) (setSum A B) int :- isType B set, isType A set, isa BB B int.

of (inl A B AA) (setSum A B) int :- isType A set, isType B set, isa AA A int.

of (elim_setSum C W Cl Cr) (CW) int :- 
    of W (setSum A B) int,
    (pi z\ of z (setSum A B) int => isType (C z) set),
    (pi x\ of x A int => of (Cl x) (C (inr A B x)) int) ,
    (pi y\ of y B int => of (Cr y) (C (inl A B y)) int) ,
    CW = C W.

hstep (elim_setSum C W Cl Cr) (Cl Wl) :- hnf W (inl A B Wl).
hstep (elim_setSum C W Cl Cr) (Cr Wr) :- hnf W (inr A B Wr).

dstep (elim_setSum C W Cl Cr) (elim_setSum C W' Cl Cr) :- dstep W W'.

dstep (elim_setSum C W Cl Cr) (elim_setSum C W Cl' Cr) :- 
    pi w\ of w (setSum A B) int => dstep (Cl w) (Cl' w).

dstep (elim_setSum C W Cl Cr) (elim_setSum C W Cl Cr') :- 
    pi w\ of w (setSum A B) int => dstep (Cr w) (Cr' w).  

dstep (elim_setSum C W Cl Cr) (elim_setSum C' W Cl Cr) :- 
    pi w\ of w (setSum A B) int => dstep (C w) (C' w).  


dstep (inl A B AA) (inl A B AA') :- dstep AA AA'.
dstep (inr A B BB) (inr A B BB') :- dstep BB BB'.


%%% Interpretation

trad (setSum A B) (setSum Ai Bi)  :- trad A Ai, trad B Bi.
trad (inl A B AA) (inl Ai Bi AAi) :- trad A Ai, trad B Bi, tau' A AA AAi.
trad (inr A B BB) (inr Ai Bi BBi) :- trad A Ai, trad B Bi, tau' B BB BBi.

trad (elim_setSum C W Cl Cr) (elim_setSum Ci Wi Cli Cri) :- 
    of W (setSum A B) ext,
    tau' (setSum A B) W Wi,
    (pi x\ of x (setSum A B) int => trad (C x) (Ci x) ),
    (pi a\ of a A int => tau' (C (inl A B a)) (Cl a) (Cli a)),
    (pi b\ of b B int => tau' (C (inl A B b)) (Cr b) (Cri b)).

sigm X Y :- of X (setSum A B) int,
    (pi a\ of a A int, sigm (Cl a) (Cl' a)),
    (pi b\ of b B int, sigm (Cr b) (Cr' b)),
    Y = elim_setSum (setSum A B) X Cl' Cr'.

%TAU input Type    output Type   input     output
tau (setPi A1 B1) (setPi A2 B2) (inl AA1) (inl AA2) :- tau A1 A2 AA1 AA2.
tau (setPi A1 B1) (setPi A2 B2) (inr BB1) (inr BB2) :- tau B1 B2 BB1 BB2.

%%equ --     non sono sicuro di che cosa dica il teorema 4.20 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%-- calc_nat.elpi

hstep (nrec T F K zero) K.
hstep (nrec T F K (succ N)) (F N (nrec F K N)).

dstep (nrec T1 F K A) (nrec T2 F K A) :- dstep T1 T2.
dstep (nrec T F K A1) (nrec T F K A2) :- dstep A1 A2.
dstep (nrec T F K1 A) (nrec T F K2 A) :- dstep K1 K2.
dstep (nrec T F1 K A) (nrec T F2 K A) :-
    pi x \ of int x nat =>
     pi y \ of int y (T x) =>
            dstep (F1 x y) (F2 x y).

dstep (succ E) (succ Q) :- bnf E Q.

isType set nat.
of int zero nat.
of int (succ A) nat :- of int A nat.
of int (nrec T F K N) (T N) :-
 of int N nat,  
 of int K (T zero),
 (pi x \ of int x nat => isType set (T x)),
 (pi x \ of int x nat =>
  pi y \ of int y (T x) => of int (F x y) (T (succ x))).
 



macro plus ( m\n\ nrec (x\nat) (x\y\ succ y) n    m ).   
macro prec ( m\   nrec (z\nat) (x\y\      x) zero m). 

intnat 0 zero.
intnat K (succ N) :- 
    K > 0, KK is K - 1, 
    intnat KK N.

natint zero 0 :- 1 = 1, !.
natint Nat Int :-
    macro prec Prec,
    printt (Prec Nat),
    nf (Prec Nat) A,
    natint A Int2,
    Int is Int2 + 1.
    
natPlus A B C :- 
    (intnat A AA), 
    (intnat B BB), 
    (macro plus Plus),
    (nf (Plus AA BB) K),
    (natint K C).



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%-- calc_id.elpi

isType (propId A AA1 AA2) prop :- 
    isa AA1 A int,
    isa AA2 A int,
    isType A _.

of (id A AA1) (propId A' AA2 AA3) int :-    
    of AA1 A'' int,
    conv A A'',
    (conv AA1 AA2),
    (conv AA1 AA3),
    (conv A A'),
    isType A col.

of (elim_id P Cc C) (C AA1 AA2) int :-
     (of P (propId A AA1 AA2) int),
    makeline "-",
     (pi x\ pi y\ of x A int => of y A int => isType (C x y) prop),
     (pi x\ of x A int => of (Cc x) (C x x) int).

hstep (elim_id (id A AA) C CC) (CC AA) :-
    (of AA A int),
    (pi x\ pi y\ of x A int => of y A int => isType (C x y) prop),
    (pi x\ of x A int  => of (CC x) (C x x) int).

dstep (id A AA) (id A' AA) :- dstep A A'.

dstep (id A AA) (id A AA') :- dstep AA AA'.

dstep (propId A Aa Ab) (propId A' Aa Ab) :- (dstep A A').
dstep (propId A Aa Ab) (propId A Aa' Ab) :- dstep Aa Aa'.
dstep (propId A Aa Ab) (propId A Aa Ab') :- dstep Ab Ab'.

dstep (elim_id P C CC) (elim_id P' C CC) :- dstep P P'.
dstep (elim_id P C CC) (elim_id P C' CC) :- 
    of P (propId A _ _) int,
    pi x\ pi y\ of x A int => of y A int => dstep (C x y) (C' x y).

dstep (elim_id P C CC) (elim_id P C CC')  :- 
    of P (propId A _ _) int,
    pi x\ of x A int => dstep (CC x) (CC' x).

%macro (id_sym P) (elim_propId P (x\id A x) (y\x\propId A x y)).
%macro (id_tra P Q) (elim_propId Q (x\id A x) (x\y\propId AA1 y))
%   :- of P (propId A AA1 AA2) int
%    , of Q (propId A' AA3 AA4) int
%    , conv A A'
%    , conv AA2 AA3 
    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%-- calc_simpleProps.elpi

%%%%Disjuntion

isType (or A B) prop :- isType A prop, isType B prop.
isType (or A B) props :- isType A props, isType B props.


of (or_r A B BB) (or A B) int :-  
        isType A prop, 
        isType B prop, 
        isa BB B int.

of (or_l A B AA) (or A B) int :-  
        isType A prop , 
        isType B prop , 
        isa AA A int.
        

of (elim_or W C Cl Cr) (C W) int :- 
    of W (or A B) int,
    isType C prop,
    (pi x\ of x A int => of (Cl x) C int),
    (pi y\ of y B int => of (Cr y) C int).

hstep (elim_or (or_l A B Wl) C Cl Cr) (Cl Wl).
hstep (elim_or (or_r A B Wr) C Cl Cr) (Cr Wr).

dstep (elim_or W C Cl Cr) (elim_or W' C Cl Cr) :- dstep W W'.

dstep (elim_or W C Cl Cr) (elim_or W C Cl' Cr) :- 
    pi w\ of w (or A B) int => dstep (Cl w) (Cl' w).

dstep (elim_or W C Cl Cr) (elim_or W C Cl Cr') :- 
    pi w\ of w (or A B) int => dstep (Cr w) (Cr' w)  

dstep (elim_or W C Cl Cr) (elim_or W C' Cl Cr) :- 
    pi w\ of w (or A B) int => dstep (C w) (C' w)  


dstep (or_l A B AA) (or_l A B AA') :- dstep AA AA'.
dstep (or_r A B BB) (or_r A B BB') :- dstep BB BB'.

dstep (or A B) (or A' B) :- dstep A A'.
dstep (or A B) (or A B') :- dstep B B'.

%-----------------------------------%
of true (or B C) ext :- isType B prop, isType C prop, of true B ext.
of true (or B C) ext :- isType B prop, isType C prop, of true C ext.
%of true D ext :- isType D prop, of true (or B C) ext,
%    (pi x\ of x B ext => of true D ext),
%    (pi x\ of x C ext => of true D ext).

%%% Conjuntion


isType (and B C) prop :-
    isType B prop,
    isType C prop.
isType (and B C) props :-
    isType B props,
    isType C props.

of (and_p B C BB CC) (and B C) int :-  
    isa BB B int, 
    isa CC C int,
    isType B prop,
    isType C prop.
    
hstep (p1 Pair) BB :-
        hnf Pair (and_p B C BB CC).

hstep (p2 Pair) CC :-
        hnf Pair (and_p B C BB CC).

dstep (and B1 C) (and B2 C) :- dstep B1 B2.
dstep (and B C2) (and B C2) :- dstep C1 C2.

dstep (and_p B1 C Bb Cc) (and_p B2 C Bb Cc) :- dstep B1 B2.

dstep (and_p B C1 Bb Cc) (and_p B C2 Bb Cc) :- dstep C1 C2.

dstep (and_p B C Bb1 Cc) (and_p B C Bb2 Cc) :- dstep Bb1 Bb2.

dstep (and_p B C Bb Cc1) (and_p B C Bb Cc2) :- dstep Cc1 Cc2.

dstep (and A B) (and A' B) :- dstep A A'.
dstep (and A B) (and A B') :- dstep B B'.

%-------------------%
of true (and B C) ext :- 
    isType B prop,
    isType C prop,
    of true B ext,
    of true C ext.

%of true B ext :-
%    isType (and B C) prop,
%    of true (and B C) ext.

%of true C ext :-
%    isType (and B C) prop,
%    of true (and B C) ext.

%%%% Implication

isType (implies B C) prop :- isType B prop, isType C prop.
isType (implies B C) props :- isType B props, isType C props.

of (lam_impl B CC) (implies B C) int :- 
    isType B prop, 
    (pi x\ of x B int => of (CC x) C int),
    isType C prop.
    
of (app_impl F BB) C int :- 
        hnf F (lam_impl B CC),
        isa BB B int,
        (pi x\ of x B int => of (CC x) C int).

hstep (app_impl (lam_impl B CC) BB) (CC BB) :-
        isa BB B int, 
        isType B prop,
        (pi x\ of x B int => of (CC x) C int),
        isType C prop.
        
dstep (app_impl F BB1) (app_impl F BB2) :- dstep BB1 BB2.       

dstep (app_impl F1 BB) (app_impl F2 BB) :-
    hnf F1 (lam_impl B CC),
    pi x\ of x B int => dstep (F1 x) (F2 x).
     

dstep (implies A B) (implies A' B) :- dstep A A'.
dstep (implies A B) (implies A B') :- dstep B B'.
%-----------------------%
of true (implies B C) ext :- 
    isType B prop,
    isType C prop,
    (pi x\ of x B ext => of true C ext).

%Questa regola diverge
of true C ext :-
    printW "-------" C,
    of true (implies B C) ext,  
    of true B ext,
    isType C prop,
    isType B prop.

%%%forall

isType  (forall B C) prop :- 
    isType B col,
    (pi x\ of x B int => isType (C x) prop).

isType  (forall B C) props :- 
    isType B set,
    (pi x\ of x B int => isType (C x) props).

of (lam_for B CC) (forall B C) int :- 
        isType B prop,
        (pi x\ of x B int => of (CC x) (C x) int)
        (pi x\ of x B int => isType  (C x) prop).

of (app_for F BB) (C BB) int :- 
        hnf F (lam_for B CC),
        isa BB B int,
        (pi x\ of x B int => of (CC x) (C x) int).

hstep (app_for F BB) (CC BB) :-
        hnf F (lam_for B CC),
        isa BB B int,
        (pi x\ of x B int => of (CC x) (C x) int).
        
dstep (app_for F BB) (app_for F' BB') :- dstep F F'.
dstep (app_for F BB) (app_for F' BB') :- dstep BB BB'. 

dstep (lam_for B CC) (lam_for B' CC') :- dstep B B'.
dstep (lam_for B CC) (lam_for B' CC') :- 
        pi x\ of x B int => dstep (CC x) (CC' x).



dstep (forall A B) (forall A' B) :- dstep A A'.
dstep (forall A B) (forall A B') :- 
    pi x\ of x A int => dstep (B x) (B' x).

%---------------------------------%

of true (forall B C) ext :- 
    (pi x\ of x B ext => of true (C x) ext),
    (pi x\ of x B ext => isType (C x) prop).

% Credo non ci sia modo di non far divergere questa regola 
%of true (C BB) ext :-
%    of BB B ext,
%    of true (forall B C) ext.
%    


%%%Exist

isType (exist B C) prop :- 
    isType B col,
    (pi x\ of x B int => isType (C x) prop).
isType (exist B C) props :- 
    isType B set,
    (pi x\ of x B int => isType (C x) props).

of (exist_p B C BB CC) (exist B C) int :- 
        isType B col,
        of BB B int,
        of CC (C BB) int,
        (pi x\ of x B int => isType (C x) prop).


of (elim_exist Pair M MM) M int :-
        of Pair (exist B C) int,
        isType M prop,
        (pi x \ pi y \
            of x B int => of y (C x) int =>  
                of (MM x y) M int ).

hstep (elim_exist (pair B C Bb Cc) M Mm) (Mm Bb Cc) :-
    of Bb B int,
    of Cc (C Bb) int,
    (pi x \ pi y \
        of x B int => of y (C x) int =>  
            of (Mm x y) M  int).
        
dstep (exist_p B C BB CC) (exist_p B' C BB CC) :- dstep B B'.
dstep (exist_p B C BB CC) (exist_p B C' BB CC) :- (pi x\ of x B int => dstep (C x) (C' x)).
dstep (exist_p B C BB CC) (exist_p B C BB' CC) :- dstep BB BB'.
dstep (exist_p B C BB CC) (exist_p B C BB CC') :- dstep CC CC'.

dstep (elim_exist Pair M MM) (elim_exist Pair' M MM) :- dstep Pair Pair'.

dstep (elim_exist Pair M MM) (elim_exist Pair M MM') :- 
    of Pair (exist B C) int,
    pi x\ pi y\ of x B int => of y (C x) int => dstep (MM x y) (MM' x y).

dstep (elim_exist Pair M MM) (elim_exist Pair M' MM) :- dstep M M'.


dstep (exist A B) (exist A' B) :- dstep A A'.
dstep (exist A B) (exist A B') :- 
    pi x\ of x A int => dstep (B x) (B' x).



%------------------------------%
of true (exist B C) ext :-
    isType B col,
    (pi x\ of x B ext => isType (C x) prop) 
    of BB B ext,
    of true (C BB) ext.

%of true M ext :-
%    isType M prop,
%    of true (exist B C) ext,
%    (pi x\ pi y\
%        of x B ext => of y (C x) ext =>
%            of true M ext).






%%%%Falsum
 
isType bottom props.
of (r0 F A) A int :- isType A prop, of F bottom int.

%----------------------%

of true A ext :- isType A prop, of true bottom ext.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%-- calc_stuff.elpi


%%POWER COLLECTION 

trad powerCol propsCol.

bnf (equ propsCol Z1 Z2) (and (implies Z1 Z2) (implies Z2 Z1))
    :- of Z1 propsCol,
       of Z2 propsCol.

bnf (subst X1 X2 W) W :- 
    of W propsCol, 
    (sigma T\ of X1 T, of X2 T).
    
trad (propsEquClass A) TA :- trad A TA.

tau_rec powerCol powerCol (x \ x).

%% EMPTYSET

trad emptyset emptyset.

equ emptyset (lambda emptyset x \ lambda emptyset y \ id emptyset x y).

trad (emp A T) (emp A' T') :-
 trad T T1, tau T T1 T',
 pi x \ trad x x => of IE x emptyset => of ext x emptyset => bnf x x =>
  trad (A x) (A1 x), tau (A x) (A1 x) (A' x). 

tau_rec emptyset emptyset (x \ x).

prove_equ (emp A T) (emp A' T') (emp (EQU T T') T) :-
 of IE T TTY, equ TTY EQU.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


