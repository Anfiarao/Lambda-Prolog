Kind  nat  type.
Type z    nat.
Type s    nat -> nat.

Theorem  succ-inj : forall x y, (s x) = (s y) -> x = y.
intros. case H1.   search.

Theorem  zero-succ : forall x, (s x) = z -> false.
intros. case H1.

Theorem  finiteness : forall x, x = (s x) -> false.
intros.   case H1.

Define  plus : nat -> nat -> nat -> prop by
plus z      N N ;
plus (s M) N (s K) := plus M N K.

Theorem  plus_two_two :
plus (s (s z)) (s (s z)) (s (s (s (s z)))).
unfold  2.  unfold  2.  unfold  1.  search.

Theorem  plus_bad : plus (s (s z)) (s z) (s (s z)) -> false.
intros. case H1. case H2. case H3.


Define q : prop by
q := (q -> false) -> false.

Define r : nat -> prop by
r z ;
r (s N) := r N -> false.


Kind  list    type.
Type  empty   list.
Type  cons    nat -> list -> list.
Define  memb : nat -> list -> prop by
memb N (cons N L) ;
memb N (cons M L) := memb N L.


Define  set_incl : list -> list -> prop by
set_incl S T :=
forall E, memb E S -> memb E T.
Define  set_eq : list -> list -> prop by
set_eq S T :=  set_incl S T
/\  set_incl T S.


Type u,v,w nat.


Theorem  ex4_lists :
set_incl (cons u (cons v empty))
(cons u (cons v (cons w empty))).
unfold. intros.
case H1.
/* case of u */
search.
case H2.
/* case of v */
search.
case H3.
/* no more  cases  */


Define  append : list -> list -> list -> prop by
append  empty L L ;
append (cons N L1) L2 (cons N L3) :=
append  L1 L2 L3.
Define  reverse : list -> list -> prop by
reverse  empty  empty ;
reverse (cons N L1) L2 :=
exists L3, reverse  L1 L3
/\  append  L3 (cons N empty) L2.





Theorem  append_1 :
append (cons u empty) (cons v (cons w empty))
(cons u (cons v (cons w empty))).
unfold. unfold. search.
Theorem  reverse_1 :
reverse (cons u (cons w (cons v empty)))
(cons v (cons w (cons u empty))).
unfold. witness  cons v (cons w empty). split.
unfold. witness  cons v empty. split.
unfold. witness  empty. split. unfold. search.
unfold. search.
unfold. unfold. search.
unfold. unfold. search.



Define  even : nat -> prop by
even z ;
even (s (s N)) := even N.
Define  odd : nat -> prop by
odd (s z) ;
odd (s (s N)) := odd N.


Define  is_nat : nat -> prop by
is_nat z ;
is_nat (s N) :=  is_nat N.


Theorem  even_odd : forall n, even n -> odd (s n).
induction  on 1.  intros. case H1.
search.
apply IH to H2. search.


Theorem even_nat : forall n, even n -> is_nat n.
induction on 1. intros. case H1. unfold. search. unfold. unfold. apply IH to H2. search.


%Theorem nat_part : forall n, is_nat n -> even n \/ odd n.

%induction on 1. intros. case H1. left. unfold. search.

Define  ack : nat -> nat -> nat -> prop by
ack z      N      (s N) ;
ack (s M) z      K      := ack M (s z) K ;
ack (s M) (s N) K      :=
exists J, ack (s M) N J /\ ack M J K.


Theorem  ack_total : forall M N,
is_nat M -> is_nat N ->
exists K, is_nat K /\ ack M N K.
