
type and mttType -> mttType -> mttType.
type and mttType -> mttType -> mttType.
type pair_and mttType -> mttType -> mttTerm -> mttTerm -> mttTerm.

%%%and

ofType (and B C) KIND IE
    :- ofType B KIND1 IE
    ,  (ofType C KIND2 IE)
    ,  (pts_prop KIND1 KIND2 KIND)
    .
    
of (pair_and B C BB CC) (and B C) IE 
    :- ofType B _ IE
    ,  (isa BB B IE)
    ,  (isa CC C IE)
    ,  (pi x\ locDecl x B => ofType (C x) _ IE)
    .

of (p1_and Pair) B IE 
    :- of Pair (and B C) IE
    .
of (p2_and Pair) C IE 
    :- of Pair (and B C) IE
    .

hstep (p1_and Pair) (Bb) :- hnf Pair (pair_and B C Bb Cc).

dconv (pair_and B C Bb Cc) (pair_and B' C' Bb' Cc')
    :- (conv B B')
    ,  (pi x\ locDecl x B => conv (C x) (C' x))
    ,  (conv Bb Bb')
    ,  (conv Cc Cc')
    .
dconv (p1_and Pair) (p1_and Pair') 
    :- (of Pair (and B C) IE)
    ,  (conv Pair Pair')
    .

dconv (and B C) (and B' C') 
    :- (conv B B')
    ,  (conv C C')
    .%%-- calc/setSigma.elpi

%% STRONG INDEXED COL SUM

type setSigma mttType -> (mttTerm -> mttType) -> mttType.
type pair mttType ->  (mttTerm -> mttType) -> mttTerm -> mttTerm -> mttTerm.
type elim_setSigma mttTerm -> (mttTerm -> mttType) -> (mttTerm -> mttTerm -> mttTerm) -> mttTerm.


ofType (setSigma B C) KIND IE 
    :- spy(ofType B KIND1 IE)
    ,  spy(pi b\ locDecl b B => ofType (C b) KIND2 IE)
    ,  (pts_fun KIND1 KIND2 KIND)
    .

of (pair B C BB CC) (setSigma B C) IE 
    :- ofType B _ IE
    ,  ofType (C BB) _ IE
    ,  isa BB B IE
    ,  isa CC (C BB) IE
    .

of (elim_setSigma Pair M MM) (M Pair) IE 
    :- spy (of Pair (setSigma B C) IE)
    ,  spy (pi z \ locDecl z (setSigma B C) => ofType (M z) _ IE)
    ,  spy (pi x \ pi y \
            locDecl x B => locDecl y (C x) =>  
                isa (MM x y) (M (pair B C x y)) IE )
    .

hstep (elim_setSigma Pair M Mm) (Mm Bb Cc) 
    :- spy(hnf Pair (pair B C Bb Cc))
    ,  spy(isa Bb B _)
    ,  spy(isa Cc (C Bb) _)
    ,  spy(pi z\ locDecl z (setSigma B C) => ofType (M z) _ IE)
    ,  spy(pi x \ pi y \
        locDecl x B  => locDecl y (C x) =>  
            isa (Mm x y) (M (pair B C x y))  IE)
    .


dconv (setSigma B C) (setSigma B' C') :- (conv B B'), (pi x\ locDecl x B => conv (C x) (C' x)).
dconv (pair B C BB CC) (pair B' C' BB' CC') 
    :- (conv B B')
    ,  (pi x\ locDecl x B => conv (C x) (C' x))
    ,  (conv BB BB)
    ,  (conv CC CC')
    .

dconv (elim_setSigma Pair M MM) (elim_setSigma Pair' M' MM') 
    :- (conv Pair Pair')
    ,  (of Pair (setSigma B C))
    ,  (pi z\ locDecl z (setSigma B C) => conv (M z) (M' z))
    ,  (pi x\ pi y\  locDecl x B => locDecl y (C x) => conv (MM x y) (MM' x y))
    .
%% calc_Eq.elpi


type propEq mttType -> mttTerm -> mttTerm -> mttType.
type eqId   mttType -> mttTerm -> mttTerm.

pts_eq K props :- pts_leq K set, !.
pts_eq _ propc.

ofType (propEq A AA1 AA2) KIND ext 
    :- ofType A KIND' ext
    ,  pts_eq KIND' KIND
    ,  isa AA1 A ext
    ,  isa AA2 A ext
    .


of (eqId C Cc) (propEq C Cc Cc) ext
    :-  spy(of Cc C ext)
    .



%dstep A B :- of _ ()

dconv (propEq A AA1 AA2) (propEq A' AA1' AA2') :- spy(conv A A'), spy(conv AA1 AA1'), spy (conv AA2 AA2').

dconv (eqId A AA) (eqId A' AA') :- conv A A', conv AA AA'.


interp (propEq A Aa1 Aa2) R 
    :- spy(equ A EquA)
    ,  spy(interp_isa Aa1 A Aa1')
    ,  spy(interp_isa Aa2 A Aa2')
    ,  spy(R = (EquA Aa1' Aa2'))
    .

interp (eqId  A Aa)  T
    :- spy(reflu A ReflA)
    ,  spy(interp Aa Aa')
    ,  T = (ReflA Aa') 
    .
reflu (propEq _ _ _) (_\id singleton star).
equ (propEq A Aa1 Aa2) (_\ _\ (propId singleton star star)).

tau (propEq T_ T1 T2) (propEq T T1' T2') (F)
    :- spy(tauequ T1 T1' T F1)
    ,  spy(tauequ T2 T2' T F2)
    ,  spy(interp_isa T1 T T1i)
    ,  spy(interp_isa T2 T T2i)
    ,  spy(interp_isa T1' T T1i')
    ,  spy(interp_isa T2' T T2i')
    ,  spy(interp T Ti)
    ,  F = x\ impl_app ( 
                impl_app ( 
                 forall_app ( 
                  forall_app ( 
                   impl_app ( 
                    forall_app ( 
                     forall_app (k_propId T) T1i) T1i') F1) T2i) T2i') F2) x
    .
tau_trasp (propEq _ _ _ ) (propEq _ _ _) (h\h'\k\ k).



tauequ  _ _ (propEq T A B) (id singleton star).

type exist mttType -> (mttTerm -> mttType) -> mttType.
type and mttType -> mttType -> mttType.
type pair_exist mttType -> mttType -> mttTerm -> mttTerm -> mttTerm.

%%%Exist

ofType (exist B C) KIND IE
    :- ofType B KIND1 IE
    ,  (pi x\ locDecl x B  => ofType (C x) KIND2 IE)
    ,  pts_for KIND1 KIND2 KIND
    .
    
of (pair_exist B C BB CC) (exist B C) IE 
    :- ofType B _ IE
    ,  (isa BB B IE)
    ,  (isa CC (C BB) IE)
    ,  (pi x\ locDecl x B => ofType (C x) _ IE)
    .

of (elim_exist Pair M MM) M IE 
    :- of Pair (exist B C) IE
    ,  ofType M KIND IE
    ,  pts_leq KIND propc
    ,  (pi x \ pi y \ locDecl x B => locDecl y (C x) =>  
                of (MM x y) M IE)
    .

hstep (elim_exist W M MM) (MM Bb Cc) 
    :- hnf W (pair_exist B C Bb Cc)
    ,  isa Bb B IE
    ,  isa Cc (C Bb) IE
    ,  (pi x \ pi y \ locDecl x B => of y (C x) =>  
            of (MM x y) M IE)
    .

dconv (pair_exist B C Bb Cc) (pair_exist B' C' Bb' Cc')
    :- (conv B B')
    ,  (pi x\ locDecl x B => conv (C x) (C' x))
    ,  (conv Bb Bb')
    ,  (conv Cc Cc')
    .
dconv (elim_exist Pair M Mm) (elim_exist Pair' M' Mm') 
    :- (conv Pair Pair')
    ,  (of Pair (exist B C) IE)
    ,  (pi x\ pi y\ locDecl x B => locDecl y (C x)
        => conv (Mm x y) (Mm' x y))
    ,  (conv M M')
    .

dconv (exist B C) (exist B' C') 
    :- (conv B B')
    ,  (pi x\ locDecl x A => conv (C x) (C' x))
    .

%%-- calc_setPi.elpi

type forall     mttType -> (mttTerm -> mttType) -> mttType.
type forall_lam mttType -> (mttTerm -> mttTerm) -> mttTerm.
type forall_app mttTerm -> mttTerm -> mttTerm.

ofType (forall B C) KIND3 IE 
    :- spy(ofType B KIND IE)
    ,  spy(pi x\ locDecl x B  => spy(ofType (C x) KIND' IE))
    ,  spy(pts_for KIND KIND' KIND3)
    .

of (forall_lam B F) (forall B C) IE
    :- (ofType B _ IE)
    ,  (pi x\ locDecl x B => isa (F x) (C x) IE)
    .

of (forall_app Lam X) (C X) IE 
    :- isa (Lam) (forall B C) IE
    ,  isa X B IE
    .


hstep (forall_app LAM Bb) (F Bb) 
    :- hnf LAM (forall_lam B F)
    ,  ofType B _ IE
    ,  isa Bb B IE
    ,  (pi x\ locDecl x B => isa (F x) (C x) IE )
    ,  (pi x\ locDecl x B => ofType (C x) KIND IE )
    .

dconv (forall B C) (forall B' C') 
    :- (conv B B')
    ,  (pi x\ locDecl x B => conv (C x) (C' x))
    .
dconv (forall_app F X) (forall_app F' X') :- (conv F F'), (conv X X').
dconv (forall_lam B F) (forall_lam B' F') 
    :- (conv B B')
    ,  (pi x\ locDecl x B =>
                (conv (F x) (F' x))
       )
    .




interp (forall B C) (forall B' C') :-
        spy (interp B B'),
        spy (pi x\ pi x' \ interp x x' => locDecl x B => locDecl x' B' => interp (C x )(C'  x')).


type propId mttType -> mttTerm -> mttTerm -> mttType.
type id     mttType -> mttTerm -> mttTerm.
type elim_id    mttTerm 
            -> (mttTerm -> mttTerm -> mttType) 
            -> (mttTerm -> mttTerm)
            -> mttTerm.

%-- calc_id.elpi

ofType (propId A AA1 AA2) KIND IE 
    :- isa AA1 A int
    ,  isa AA2 A int
    ,  ofType A KIND1 int
    ,  (spy(pts_leq KIND1 set , KIND = props), ! 
       ;  KIND = propc)
    .

of (id A AA) (propId A AA AA) int 
    :- ofType A _ int
    ,  isa AA A int
    .

of (elim_id P C CC) (C AA1 AA2) int
    :- (of P (propId A AA1 AA2) int)
    , (pi x\ pi y\ locDecl x A => locDecl y A => isaType (C x y) propc int)
    , (pi x\ locDecl x A => of (CC x) (C x x) int)
    .

hstep (elim_id (id A AA) C CC) (CC AA)
    :- (isa AA A int)
    ,  (pi x\ pi y\ locDecl x A => locDecl y A => isaType (C x y) propc int)
    ,  (pi x\ locDecl x A => of (CC x) (C x x) int)
    .

dconv (id A AA) (id A' AA') :- (conv A A'),(conv AA AA').

dconv (propId A AA1 AA2) (propId A' AA1' AA2') :- spy (conv A A'), spy (conv AA1 AA1'), spy(conv AA2 AA2').

%%-- implies.elpi

type implies    mttType -> mttType -> mttType.
type impl_lam   mttType -> (mttTerm -> mttTerm) -> mttTerm.
type impl_app   mttTerm -> mttTerm -> mttTerm.


ofType (implies B C) KIND IE
    :- ofType B KIND IE
    ,  (pi x\ locDecl x B => ofType C KIND IE)
    .

of (impl_lam B F) (implies B C) IE
    :- (isaType B propc IE)
    ,  (isaType C propc IE)
    ,  (pi x\ locDecl x B => isa (F x) C IE)
    .

of (impl_app Lam X) C IE
    :- spy(isa Lam (implies B C) IE)
    ,  spy(isa X B IE)
    .

hstep (impl_app LAM Bb) (F Bb)
    :- hnf LAM (impl_lam B F)
    ,  ofType B KIND IE
    ,  (pts_leq KIND propc)
    ,  isa Bb B IE
    ,  (pi x\ locDecl x B => isa (F x) (C x) IE )
    ,  (pi x\ locDecl x B => ofType (C x) KIND' IE )
    ,  pts_leq KIND' propc
    .

        
dconv (implies B C) (implies B' C') :- (conv B B'), (conv C C').
dconv (impl_app F X) (impl_app F' X') :- (conv F F'), (conv X X').
dconv (impl_lam B F) (impl_lam B' F') 
    :- (conv B B')
    ,  pi x\ locDecl x B =>
                (conv (F x) (F' x)).








interp (implies B C) (forall B' C') 
    :- interp B B'
    ,  spy(pi x\ pi x'\ 
        (  interp x x'
        ,  locDecl x B
        ,  locDecl x' B') 
            =>  interp C (C' x')
    )
    .
type letIn mttType -> mttTerm -> (mttTerm -> mttTerm) -> mttTerm.

of (letIn T M N) T' ext :- 
spy(    isaType T propc ext),
spy(    isa M T ext), 
spy(    pi x \ locDecl x T =>  of (N x) T' ext).


ofType (letIn KIND1 T S) KIND2 ext :- 
spy(    isaType T KIND1 ext), 
spy(    pi x \ locDecl x KIND1 =>  ofType  (N x) KIND2 ext).



%hstep (letIn T M N) (N M) :-
%    of (letIn T M N) _ ext.



%hstep (letIn T M N) (N M).




type or mttType -> mttType -> mttType.
type inl_or, inr_or mttType -> mttType -> mttTerm -> mttTerm.
type elim_or mttType -> mttTerm -> mttTerm -> mttTerm -> mttTerm.

ofType (or A B) KIND IE 
    :- ofType A KIND1 IE
    ,  ofType B KIND2 IE
    ,  (pts_prop KIND1 KIND2 KIND).

of (inr_or A B Bb) (or A B) IE 
    :- ofType B _ IE
     , ofType A _ IE
     , (isa Bb B IE)
     .

of (inl_or A B Aa) (or A B) IE  
    :- ofType A _ IE
     , ofType B _ IE
     , (isa Aa A IE)
     .

of (elim_or C W Cl Cr) C IE 
    :- spy (of W (or A B) IE)
     , spy (ofType (or A B) _ IE) 
     , spy (pi z\ locDecl z (or A B) => ofType C KIND IE)
     , spy (pi x\ locDecl x A => spy(isa (Cl x) C IE) ) 
     , spy (pi y\ locDecl y B => isa (Cr y) C IE) 
     .

hstep (elim_or C W Cl Cr) (Cl Wl) 
    :- (hnf W (inl_or A B Wl))
    ,  (isa W (or A B) IE)
    ,  (pi z\ locDecl z (or A B) => ofType C KIND IE)
    ,  (pi x\ locDecl x A IE => isa (Cl x) C IE) 
    ,  (pi y\ locDecl y B IE => isa (Cr y) C IE)
    .

hstep (elim_or C W Cl Cr) (Cr Wr)
    :- (hnf W (inr_or A B Wr))
    ,  (isa W (or A B) IE)
    ,  (pi z\ locDecl z (or A B) => ofType C KIND IE)
    ,  (pi x\ locDecl x A IE => isa (Cl x) C IE) 
    ,  (pi y\ locDecl y B IE => isa (Cr y) C IE)
    .

dconv (elim_or C W Cl Cr) (elim_or C' W' Cl' Cr')
    :- (conv W W')
    ,  (of W (or A B) IE)
    ,  (pi z \ locDecl z (or A B) => (conv C C') )
    ,  (pi z \ locDecl z (or A B) => (conv (Cl z) (Cl' z) ) )
    ,  (pi z \ locDecl z (or A B) => (conv (Cr z) (Cr' z) ) )
    .

%%-- calc_setSum.elpi

type setSum mttType -> mttType -> mttType.
type inl, inr mttType -> mttType -> mttTerm -> mttTerm.
type elim_setSum mttType -> mttTerm -> mttTerm -> mttTerm -> mttTerm.
%%Disjoint Sum Type

ofType (setSum A B) KIND IE :- ofType A KIND1 IE, ofType B KIND2 IE,
    pts_fun KIND1 KIND2 KIND.

of (inr A B Bb) (setSum A B) IE 
    :- ofType B _ IE
     , ofType A _ IE
     , isa Bb B IE
     .

of (inl A B Aa) (setSum A B) IE  
    :- ofType A _ IE
     , ofType B _ IE
     , isa Aa A IE
     .

of (elim_setSum C W Cl Cr) (C W) IE 
    :- spy (of W (setSum A B) IE)
     , spy (ofType (setSum A B) _ IE) 
     , spy (pi z\ locDecl z (setSum A B) => ofType (C z) KIND IE)
     , spy (pi x\ locDecl x A => spy(isa (Cl x) (C (inr A B x)) IE) ) 
     , spy (pi y\ locDecl y B => isa (Cr y) (C (inl A B y)) IE) 
     .

hstep (elim_setSum C W Cl Cr) (Cl Wl) 
    :- hnf W (inl A B Wl)
    ,  isa W (setSum A B) IE
    ,  (pi z\ locDecl z (setSum A B) => ofType (C z) KIND IE)
    ,  (pi x\ locDecl x A IE => isa (Cl x) (C (inr A B x)) IE) 
    ,  (pi y\ locDecl y B IE => isa (Cr y) (C (inl A B y)) IE)
    .
hstep (elim_setSum C W Cl Cr) (Cr Wr) 
    :- hnf W (inr A B Wr)
    ,  isa W (setSum A B) IE
    ,  (pi z\ locDecl z (setSum A B) => ofType (C z) KIND IE)
    ,  (pi x\ locDecl x A IE => isa (Cl x) (C (inr A B x)) IE) 
    ,  (pi y\ locDecl y B IE => isa (Cr y) (C (inl A B y)) IE)
    .

dconv (elim_setSum C W Cl Cr) (elim_setSum C' W' Cl' Cr')
    :- (conv W W')
    ,  (of W (setSum A B) IE)
    ,  (pi z \ locDecl z (setSum A B) => (conv (C z) (C' z) ) )
    ,  (pi z \ locDecl z (setSum A B) => (conv (Cl z) (Cl' z) ) )
    ,  (pi z \ locDecl z (setSum A B) => (conv (Cr z) (Cr' z) ) )
    .























































































%%-- calc_singleton.elpi

%ofType star singleton set IE.

type  singleton mttType.
type  star mttTerm.
type  elim_singleton mttTerm -> (mttTerm -> mttType) -> mttTerm -> mttTerm.

ofType singleton set IE.

of star singleton IE.

of (elim_singleton Star C Cc) (C Star) IE :-
    of Star singleton IE,
    of Cc (C star) IE,
    (pi z\ locDecl z singleton => ofType (C z) col IE).

hstep (elim_singleton star C Cc) Cc :-
    of Cc (C star) IE,
    (pi z\ locDecl z singleton => ofType (C z) col IE ).

dconv (elim_singleton T C CC) (elim_singleton T' C' CC') :- conv T T' , conv CC CC',
    (pi z\ locDecl z singleton => conv (C z) (C' z)).



equ singleton (x\ y\ propId singleton x y).
reflu singleton (x\ id singleton x).



interp singleton singleton.
interp star star.





