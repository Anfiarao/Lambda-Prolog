bnf (nrec T F K zero) K.
bnf (nrec T F K (succ N)) (F N (nrec F K N)).

bnf (nrec T1 F K A) (nrec T2 F K A) :- bnf T1 T2.
bnf (nrec T F K A1) (nrec T F K A2) :- bnf A1 A2.
bnf (nrec T F K1 A) (nrec T F K2 A) :- bnf K1 K2.
bnf (nrec T F1 K A) (nrec T F2 K A) :-
    pi x \ bnf x x => of x nat =>
     pi y \ bnf y y => of y (T x) =>
            bnf (F1 x y) (F2 x y).

bnf (succ E) (succ Q) :- bnf E Q.
bnf zero zero.

isType set nat.
of zero nat.
of (succ A) nat :- of A nat.
of (nrec T F K A) (T A) :-
 of A nat,
 of K (T zero),
 (pi x \ bnf x x => of x nat => isType set (T x)),
 (pi x \ bnf x x => of x nat =>
  pi y \ bnf y y => of y (T x) => of (F x y) (T (succ x))).

%%%%  DEPENDENT PRODUCT
isType set (setPi B C) :-    % SET FORMATION
    conv B BB,
    isType set BB, 
    pi x\ bnf x x => of x B => isType set (C x).

of (lambda B F) (setPi B C) :-  % ELEMENT FORMATION
    conv B BB,
    isType set (setPi BB C), %quesa sostituzione non è valida, l'implicazione è al contrario
    pi x\ bnf x x => of x B => of (F x) (C x).

of (app Lam X) (CX) :- % ELEMENT ELIMINATION
    of Lam (setPi B C),
    isa X B,
    CX = C X.

bnf ( app (lambda B F) Bb) (F Bb) :- of Bb B, of (lambda B F) (setPi B C).
bnf (lambda B1 F) (lambda B2 F) :- bnf B1 B2.
bnf (lambda B F1) (lambda B F2) :- pi b\ of b B => bnf b b => bnf (F1 b) (F2 b).

bnf (app L X1) (app L X2) :- bnf X1 X2.
bnf (app L1 X) (app L2 X) :- bnf L1 L2.

%% STRONG INDEXED COL SUM

isType col (colSigma B C) :-
 isType K B,
 pi b\ 
    bnf b b => of b B => isType col (C b).

of ( pair B C Bb Cc ) (colSigma B C) :-  
    isType col (C Bb),
    isType col B, %quando invoco isa non controllo che il tipo fornito sia 
                  %corretto al più controllo che la sua forma normale lo sia. 
    isa Bb B, 
    isa Cc (C Bb),
    isType col (colSigma B C).

of (elimSigma B C M Pair Mm) (M D) :-
        isa Pair (colSigma B C),
%       of  Pair (colSigma BB CC),
        (pi z\ bnf z z => of z (colSigma B C) => isType col (M z)),
        (pi x\
          pi y\
            (bnf x x, bnf y y, of x B, of y (C x)) =>  of (Mm x y) (M (pair B C x y))).



bnf (elimSigma B C M (pair B C Bb Cc) Mm) (Mm Bb Cc) :-
    (pi z\ of z (colSigma B C) => bnf z z => isType col (M z)),
     of (pair B C Bb Cc) (colSigma B C),
    (pi x\
      pi y\
        (bnf x x, bnf y y, of x B, of y (C x)) =>  of (Mm x y) (M (pair B C x y)))


bnf (pair B1 C Bb Cc) (pair B2 C Bb Cc) :- bnf B1 B2.
bnf (pair B C1 Bb Cc) (pair B C2 Bb Cc) :- pi b\ of b B => bnf b b => bnf (C1 b) (C2 b).
bnf (pair B C Bb1 Cc) (pair B C Bb2 Cc) :- bnf Bb1 Bb2.
bnf (pair B C Bb Cc1) (pair B C Bb Cc2) :- bnf Cc1 Cc2.

bnf (elimSigma B C M D1 Mm) (elimSigma B C M D2 Mm) :- bnf D1 D2.
bnf (elimSigma B C M D Mm1) (elimSigma B C M D Mm2) :- bnf Mm1 Mm2.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%EMPTY SET

isType set n0.

of (emp Null) (A_Null) :- of Null n0, (pi z\ (bnf z z, of z n0) => isType col (A z)), A_Null = A Null. 

bnf (emp A) (emp A') :- bnf A A'.

% SINGLETON SET

isType set n1.

of star n1.

bnf star star.

of (elim_n1 T C) (M T) :- of T n1, (pi z\ bnf z z => of z n1 => isCol (M z) ), of C (M star). 

bnf (elim_n1 star C) C :- (pi z\ bnf z z => of z n1 => isCol (M z) ), of C (M star).
bnf (elim_n1 T C) (elim_n1 T' C) :- bnf T T'.

% Disjoint Sum Set


