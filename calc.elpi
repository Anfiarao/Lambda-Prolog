%include calc.
bracket Pre G Post :- print Pre, term_to_string G S, print S, print Post.
announce G :- bracket ">>" G "\n", fail.
spy G :- (bracket "[Entering " G "\n", G, bracket "]Success  " G "\n";
          bracket "]Leaving  " G "\n",  fail).
success.
%printt A :- term_to_string A S, print"]>-+-+-+-+[> ", print S, print "\n".

nf A B  :- announce ( nf A B).
%bnf A B :- announce (bnf A B).
%printt T:- announce (printt T) ; success.
%natint A B :- announce ( natint A B).
%intnat A B :- announce ( intnat A B).

conv A B :- nf A B ; (nf A C, nf B C).
nf A A :- (bnf A A), ! .
nf A B :- (bnf A C), nf C B .

%bnf X XX :- defs X XX _.
of X Y :- defs X _ Y.
isType col A :- isType set A.

conv A B :- nf A B ; (nf A C, nf B C).

load_library [] GOAL :- GOAL.
load_library [ddd NAME BODY | TAIL ] GOAL :-
 of BODY TYPE,
 defs NAME BODY TYPE => load_library TAIL GOAL.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
bnf (nrec T F K zero) K.
bnf (nrec T F K (succ N)) (F N (nrec F K N)).  %% UGUAGLIANZA / Beta regole

bnf (nrec T F K A1) (nrec T F K A2) :- bnf A1 A2.
bnf (nrec T F K1 A) (nrec T F K2 A) :- bnf K1 K2.
bnf (nrec T F1 K A) (nrec T F2 K A) :-
 pi x \ bnf x x => of x nat =>
 pi y \ bnf y y => of y (T x) =>
 bnf (F1 x y) (F2 x y).

bnf (succ E) (succ Q) :- bnf E Q.
bnf zero zero.

isType set nat.
of zero nat.
of (succ A) nat :- of A nat.
of (nrec T F K A) (T A) :-
 of A nat,
 of K (T zero),
 (pi x \ bnf x x => of x nat => isType set (T x)),
 (pi x \ bnf x x => of x nat =>
  pi y \ bnf y y => of y (T x) =>
  of (F x y) (T (succ x))).

%%%%
isType set (setPi A B) :-    % SET FORMATION
    isType set A, 
    pi x\ of x A => 
        bnf x x => 
            isType set (B x).


of (lambda B F) (setPi B C) :-  % ELEMENT FORMATION
    isType set (setPi B C), 
    pi x\ of x B => bnf x x => of (F x) (C x).

of (app Lam X)  (CX) :- % ELEMENT ELIMINATION
    of Lam (setPi B C),
    of X B,
    CX = C X.

pi b\   %% le variabili libere vengono implicitamente quantificate
  bnf ( app (lambda B F) b) (F b) :- of b B, of (lambda B F) (setPi B C).


bnf (lambda B1 F) (lambda B2 F) :- bnf B1 B2.
bnf (lambda B F1) (lambda B F2) :- pi b\ of b B => bnf b b => bnf (F1 b) (F2 b).

bnf (app L X1) (app L X2) :- bnf X1 X2.
bnf (app L1 X) (app L2 X) :- bnf L1 L2.





%MACROs and stuff.






macro plus ( nrec x\y\succ y ).   %%%MACROOOOOOOOOOOOOOOO!!!!!!!!!!!!!1
macro prec ( nrec (x\y\x) zero). 




intnat 0 zero.
intnat K (succ N) :- 
    K > 0, KK is K - 1, 
    intnat KK N.

natint zero 0 :- 1 = 1, !.
natint Nat Int :-
    macro prec Prec,
    printt (Prec Nat),
    nf (Prec Nat) A,
    natint A Int2,
    Int is Int2 + 1
    .


natPlus A B C :- 
    (intnat A AA), 
    (intnat B BB), 
    (macro plus Plus),
    (nf (Plus AA BB) K),
    (natint K C).



%is_canon zero.  is_canon succ.  is_const nrec.

