% SINGLETON SET

accumulate calc_singleton.

trad singleton singleton.
trad star star.

tau singleton singleton star star.

sigm singleton singleton DIR.
sigm W W DIR :- of W singleton int.

equ singleton X Y (propId singleton X Y)  
    :- isa X singleton int 
     , isa Y singleton int.

trad (elim_singleton T  C  Cc ) 
     (elim_singleton T' C' Cc') 
    :- tau' singleton T T',
     (pi xe \ pi xi \ 
        trad xe xi => 
        of xi singleton int => 
        of xe singleton ext =>
        ( 
         trad (C xe) (C' xi),
         tau' (C star) Cc Cc'
        ) 
     ).

     
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%-- calc_empty.elpi

accumulate calc_empty.

tau empty empty A A.

trad bottom bottom.
trad empty empty.
trad (emp X A) (emp X' A') 
   :- tau' empty X X'
    , (pi xe\ pi xi\ of xe empty ext 
                     => of xi empty int 
                     => trad xe xi 
                     => trad (A xe) (A' xi))
    .

sigm Z Z DIR :- of Z empty int.    

equ empty X1 X2 (propId empty X1 X2).
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%-- calc_setPi.elpi

%%% DEPENDENT PRODUCT SET

trad 
   (setPi B C) 
   (colSigma 
       (setPi TradB TradC)
       (H\
           (forall TradB y1\
               (forall TradB y2\
                   (forall (EQUB y1 y2) d \
                       (EQUC y2 (SIGMA y1 y2 (app H y1)) (app H y2)
                       )
                   )
               )
           )
       )
   )
   :- trad B TradB ,
   (pi ye\ 
        pi yi\ trad ye yi 
            => of ye B ext 
            => of yi TradB int
            => trad (C ye) (TradC1 yi)) 
   equ TradB EQUB,
   (pi y \ equ (TradC y) (EQUC y)),
   (pi y1 \ pi y2 \ pi z \ sigma y1 y2 => sigm z (SIGMA z)).

trad (lambda B F) 
     (pair XX1 XX2 
        (lambda TradB TradF) 
        (emp bottom XX3) )
   :- trad B TradB
    , pi xe\ pi xi\ trad xe xi => trad (F xe) (TradF xi)
    .
      % (of (lambda B F) 
          % (setPi B T_inferred_ext)
           % ext
      % )
               
      % (pi xe \ pi xi \ trad xe xi => 
       % trad (F xe) (TradF xi),
       % of (TradF xi) (T_inferred xi),
       % trad (T_inferred_ext xe) (T_inferred_ext_trad xi),
       % tau (T_inferred xi) (T_inferred_ext_trad xi) (TAU xi)),
      % equ TradB EQU,
      % (pi x1 \ pi x2 \ pi d \ prove_equ x1 x2 d => sigma x1 x2 =>
        % sigma (TradCc x1) UUU,
        % prove_equ UUU (TradCC x2) PROVEEQ),
      % P = lambda TradB x1 \ lambda TradB x2 \ lambda (EQU x1 x2) d \
           % PROVEEQ x1 x2 d.


%%equ (setPi B C) something.

%% ££££££££££££££ TODO ££££££££££££££££££££

%% £££££££ sigm A B =====> sigm DIR A B

%sigm DIR A B :- hsigm DIR A B.
%sigm DIR A B :- dir_inv DIR INVDIR, hsigm INVDIR B A.

%dir_inv forward backward.
%dir_inv backward forward.

%sigm DIR W W' :-
% of int W (colSigma (setPi BI CI) _),
% print "TIPAGGIO \n\n",
% sigm DIR BI BI',
% print "step2\n\n",
% (pi x \ of int x BI => sigm DIR (CI x) (CI' x)),
% print "step3\n",
% (pi a \ pi b \ of int a BI => of int b BI => equ BI' a b (EQBI' a b)),
% print "qweqwe\n",
% (pi x2 \ pi a \ pi b \ of int x2 BI' => of int a (CI' x2) => of int b (CI' x2) =>
%   equ (CI' x2) a b (EQCI'x2 x2 a b)),
% print "qweqwe2\n",
% (pi x1 \ pi x2 \ pi x \ of int x2 BI' => of int x1 BI' hsigm DIR x1 x2 => of int x (CI' x1) => sigm DIR x (SIGfx1 x1 x2 x)), 
% print "qweqwe3\n",
% 
% W' = pair (setPi BI' CI')
%  (f \ forall BI' x1 \ forall BI' x2\
%    implies (EQBI' x1 x2) (EQCI'x2 x2 (SIGfx1 x1 x2 (app f x1)) (app f x2)))
%  F' P',
% 
% macro (fst W) F,
% macro (snd W) P,
% print "SIGMI!!",
% dir_inv INV INVDIR,
% (pi y \ of int y BI' => sigm INVDIR (INVSIG y) y),
% print "QWEQWEQWE 4\n\n",
% (pi y \ pi x \ of int y BI' => of int x (CI (INVSIG y)) => hsigm DIR (INVSIG y) y => sigm DIR x (SIG2 x)),
% print "QWEQWEQWQWEQWE\n",
% F' = (lam BI' y \ SIG2 (F (INVSIG y))),
% P' = delirio_assoluto.


%testxxx W' :-
% W = pair (setPi singleton x \ singleton) (x\singleton) (lam singleton x \ x) star,
% sigm forward W W'.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%-- calc_setSum.elpi

%%% Interpretation

trad (setSum A B) (setSum TradA TradB)  
    :- trad A TradA, trad B TradB.
trad (inl A B Aa) (inl TradA TradB TradAa_expected) 
    :- trad A TradA, trad B TradB, tau' A Aa TradAa_expected.
trad (inr A B Bb) (inr Ai Bi TradBb_expected) 
    :- trad A TradA, trad B TradB, tau' B Bb TradB_expected.

trad (elim_setSum C W Cl Cr) (elim_setSum TradC TradW TradCl TradCr) :- 
    of W (setSum A B) ext,
    trad (setsum A B) A+B,
    tau' (setSum A B) W TradW,
    (pi xe\ of xe (setSum A B) ext
        pi xi \ trad xe xi => trad (C xe) (TradC xi) ),
    (pi xe\ of xe A ext
        pi xi \ trad xe xi => 
            tau' (C (inl A B xe)) (Cl xe) (TradCl xi)),
    (pi xe\ of xe B ext
        pi xi \ trad xe xi => 
            tau' (C (inr A B xe)) (Cr xe) (TradCr xi)).

sigm X (elim_setSum (setSum A B) X Cl' Cr') DIR 
    :- of X (setSum A B) int
     , pi y\ of y A int => sigm y (Cl' y) DIR
     , pi y\ of y B int => sigm y (Cr' y) DIR
     .

tau (setPi A1 B1) (setPi A2 B2) (inl AA1) (inl AA2) 
    :- tau A1 A2 AA1 AA2, tau B1 B2 BB1 BB2.
