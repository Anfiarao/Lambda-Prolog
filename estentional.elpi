
extIsType col A :- extIsType set A.
extIsType col A :- extIsType prop A.

extIsType col (extSigma B C) :- pi x\ extOf x B => bnf x x => extIsType col (C x).
extOf (pair Bb Cc) (extSigma B C) :- 
%%%%  DEPENDENT PRODUCT
isType set (setPi A B) :-    % SET FORMATION
    isType set A, 
    pi x\ of x A => 
        bnf x x => 
            isType set (B x).


of (lambda B F) (setPi B C) :-  % ELEMENT FORMATION
    isType set (setPi B C), 
    pi x\ of x B => bnf x x => of (F x) (C x).

of (app Lam X)  (CX) :- % ELEMENT ELIMINATION
    of Lam (setPi B C),
    of X B,
    CX = C X.

pi b\   %% le variabili libere vengono implicitamente quantificate
  bnf ( app (lambda B F) b) (F b) :- of b B, of (lambda B F) (setPi B C).
  
bnf (lambda B1 F) (lambda B2 F) :- bnf B1 B2.
bnf (lambda B F1) (lambda B F2) :- pi b\ of b B => bnf b b => bnf (F1 b) (F2 b).

bnf (app L X1) (app L X2) :- bnf X1 X2.
bnf (app L1 X) (app L2 X) :- bnf L1 L2.

%% STRONG INDEXED SUM

isType col (colSigma B C) :- pi b\ 
    bnf b b => of b B => isType col (C b).

pi b\ 
  pi c\ 
    of ( pair B C b c ) (colSigma B C) :-  bnf b b, of b B, bnf c c, of c (C b), isType col (colSigma B C).

pi m\
  pi d\
    of (elimSigma B C M d m) (M d) :-
        (pi z\ of z (colSigma B C) => bnf z z => isType col (M z)),
        bnf d d,
        of d (colSigma B C),
        (pi x\
          pi y\
            (bnf x x, bnf y y, of x B, of y (C x)) =>  of (m x y) (M (pair B C b c))).


pi b\
 pi c\
  pi m\
    bnf (elimSigma B C M (pair B C b c) m) (m b c) :- %% bnf forse deve essere arricchita con il tipo bnf T X1 X2
        (pi z\ of z (colSigma B C) => bnf z z => isType col (M z)),
        of (pair B C b c) (colSigma B C),
        (pi x\
          pi y\
            (bnf x x, bnf y y, of x B, of y (C x)) =>  of (m x y) (M (pair B C b c)))

%% Chiusura contestuale

bnf (pair B1 C b c) (pair B2 C b c) :- bnf B1 B2.
bnf (pair B C1 b c) (pair B C2 b c) :- pi b\ of b B => bnf b b => bnf (C1 b) (C2 b).
bnf (pair B C b1 c) (pair B C b2 c) :- bnf b1 b2.
bnf (pair B C b c1) (pair B C b c2) :- bnf c1 c2.

bnf (elimSigma B C M d1 m) (elimSigma B C M d2 m) :- bnf d1 d2.
bnf (elimSigma B C M d m1) (elimSigma B C M d m2) :- bnf m1 m2.








%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
bnf (nrec T F K zero) K.
bnf (nrec T F K (succ N)) (F N (nrec F K N)).  %% UGUAGLIANZA / Beta regole

bnf (nrec T F K A1) (nrec T F K A2) :- bnf A1 A2.
bnf (nrec T F K1 A) (nrec T F K2 A) :- bnf K1 K2.
bnf (nrec T F1 K A) (nrec T F2 K A) :-
 pi x \ bnf x x => of x nat =>
 pi y \ bnf y y => of y (T x) =>
 bnf (F1 x y) (F2 x y).

bnf (succ E) (succ Q) :- bnf E Q.
bnf zero zero.

isType set nat.
of zero nat.
of (succ A) nat :- of A nat.
of (nrec T F K A) (T A) :-
 of A nat,
 of K (T zero),
 (pi x \ bnf x x => of x nat => isType set (T x)),
 (pi x \ bnf x x => of x nat =>
  pi y \ bnf y y => of y (T x) =>
  of (F x y) (T (succ x))).

