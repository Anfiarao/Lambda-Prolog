

isType set (setPi B C) :-
    isType set B, 
    pi x\ of x B int => isType (C x) set.

of (lam B CC) (setPi B C) int :-
        isType B int,
        pi x\ of x B int => of (CC x) (C x) int.

of (app Lam X) (C X) int :-
        hnf Lam (lam B CC),
        of (lam B CC) (setPi B C) int,
        isa X B int. 


hstep (app LAM BB) (CC BB) :- 
        hnf LAM (lambda B CC),
        isType B set,
        isa BB B int,
        (pi x\ of x B int => of (CC x) (C x) int ),
        (pi x\ of x B int => isType (C x) set ).

dstep (lambda B1 F) (lambda B2 F) :- dstep B1 B2.

dstep (lambda B F1) (lambda B F2) :- 
        pi b\ of b B int => dstep (F1 b) (F2 b).

dstep (app L X1) (app L X2) :- dstep X1 X2.
dstep (app L1 X) (app L2 X) :- dstep L1 L2.






%%% DEPENDENT PRODUCT SET

%trad 
%    (setPi B C) 
%    (colSigma 
%        (setPi TradB TradC)
%        (H\
%            (forall TradB y1\
%                (forall TradB y2\
%                    (forall (EQUB y1 y2) d \
%                        (EQUC y2 (SIGMA y1 y2 (app H y1)) (app H y2)
%                        )
%                    )
%                )
%            )
%        )
%    )
%    :- trad B TradB ,
%    (pi ye\ 
%         pi yi\ trad ye yi 
%             => of ye B ext 
%             => of yi TradB int
%             => trad (C ye) (TradC1 yi)) 
%    equ TradB EQUB,
%    (pi y \ equ (TradC y) (EQUC y)),
%    (pi y1 \ pi y2 \ pi z \ sigma y1 y2 => sigm z (SIGMA z)).

%trad (lambda B Cc) (pair (lambda TradB TradCc) P )
%    :- trad B TradB,
%       (of  
%            (lambda B Cc) 
%            (setPi B T_inferred_ext)
%            ext),
%       (pi x \ trad x x => 
%        trad (Cc x) (TradCc x), of (TradCc x) (T_inferred x),
%         trad (T_inferred_ext x) (T_inferred_ext_trad x),
%         tau (T_inferred x) (T_inferred_ext_trad x) (TAU x)),
%       equ TradB EQU,
%       (pi x1 \ pi x2 \ pi d \ prove_equ x1 x2 d => sigma x1 x2 =>
%         sigma (TradCc x1) UUU,
%         prove_equ UUU (TradCC x2) PROVEEQ),
%       P = lambda TradB x1 \ lambda TradB x2 \ lambda (EQU x1 x2) d \
%            PROVEEQ x1 x2 d.


%%equ (setPi B C) something.

%% ££££££££££££££ TODO ££££££££££££££££££££

%% £££££££ sigm A B =====> sigm DIR A B

%sigm DIR A B :- hsigm DIR A B.
%sigm DIR A B :- dir_inv DIR INVDIR, hsigm INVDIR B A.

%dir_inv forward backward.
%dir_inv backward forward.

%sigm DIR W W' :-
% of int W (colSigma (setPi BI CI) _),
% print "TIPAGGIO \n\n",
% sigm DIR BI BI',
% print "step2\n\n",
% (pi x \ of int x BI => sigm DIR (CI x) (CI' x)),
% print "step3\n",
% (pi a \ pi b \ of int a BI => of int b BI => equ BI' a b (EQBI' a b)),
% print "qweqwe\n",
% (pi x2 \ pi a \ pi b \ of int x2 BI' => of int a (CI' x2) => of int b (CI' x2) =>
%   equ (CI' x2) a b (EQCI'x2 x2 a b)),
% print "qweqwe2\n",
% (pi x1 \ pi x2 \ pi x \ of int x2 BI' => of int x1 BI' hsigm DIR x1 x2 => of int x (CI' x1) => sigm DIR x (SIGfx1 x1 x2 x)), 
% print "qweqwe3\n",
% 
% W' = pair (setPi BI' CI')
%  (f \ forall BI' x1 \ forall BI' x2\
%    implies (EQBI' x1 x2) (EQCI'x2 x2 (SIGfx1 x1 x2 (app f x1)) (app f x2)))
%  F' P',
% 
% macro (fst W) F,
% macro (snd W) P,
% print "SIGMI!!",
% dir_inv INV INVDIR,
% (pi y \ of int y BI' => sigm INVDIR (INVSIG y) y),
% print "QWEQWEQWE 4\n\n",
% (pi y \ pi x \ of int y BI' => of int x (CI (INVSIG y)) => hsigm DIR (INVSIG y) y => sigm DIR x (SIG2 x)),
% print "QWEQWEQWQWEQWE\n",
% F' = (lam BI' y \ SIG2 (F (INVSIG y))),
% P' = delirio_assoluto.


%testxxx W' :-
% W = pair (setPi singleton x \ singleton) (x\singleton) (lam singleton x \ x) star,
% sigm forward W W'.

