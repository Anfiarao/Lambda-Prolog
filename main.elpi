%-- non contextual, non reflexive, maybe transitive closure
%-- hstep A B
%---- non contextual, transitive, reflexive normal form
%-- hnf A B
%---- contextual, non reflexive, maybe transitive closure
%-- dstep A B

/* UNITYPED COMPUTATIONAL PREDICATES */
type hstep, dconv, hnf,  conv, interp A -> A -> prop. 
 
/*MTT PREDICATES*/
kind mttTerm,               mttType, mttKind, mttLevel type.
type ext, int               mttLevel.
type col, set, propc, props mttKind.


type locDecl            mttTerm -> mttType -> prop.
type locDeclType        mttType -> mttKind -> prop.
type isType             mttType -> mttKind -> mttLevel -> prop.
type of, isa            mttTerm -> mttType -> mttLevel -> prop.

type locDef         mttTerm -> mttType -> mttTerm -> prop.

type forall mttType -> (mttTerm -> mttType) -> mttType.

 

hnf A B :- hstep A C, !, hnf C B.
hnf A A.

%dstep A B :- spy(hstep A B).
%nf A B :- spy (dstep A C), !, spy(nf C B). %con le regole di eq dstep è diventata riflessiva, 
%nf A A.                         % ho aggiunto il not in eq.elpi per evitare che ciò accada

conv A A :- ! .
conv A B :- (locDecl _ (propEq _ A B) ).
conv A B :- spy(hnf A A'), spy( hnf B B'), spy( dconv A' B').

dconv A A :- !.
 
pts_leq A A.
pts_leq props set.
pts_leq props col.
pts_leq props propc.
pts_leq set col.
pts_leq propc col.


pts_prop props props props :- !.
pts_prop _ _ propc.

pts_fun A B set :- spy(pts_leq A set), spy(pts_leq B set), !.
pts_fun _ _ col.

pts_for A props props :- pts_leq A set, !.
pts_for _ _ propc. 


%isType A KIND IE :- locDeclType A KIND .

isaT Type Kind IE :-
spy ( isType Type Kind' IE),
spy  (pts_leq  Kind' Kind).

of (fixMe2 M T ) T int 
    :- !
    ,  print "|||||||||||||||||||||||||||||||||||||||||\n|||||||||||||||||||||||||||||||||||||||||\n"
    ,  print M
    ,  term_to_string T S, print S
    ,  print "|||||||||||||||||||||||||||||||||||||||||\n|||||||||||||||||||||||||||||||||||||||||\n"
    .

isa (fixMe M) T int 
    :- !
    ,  print "|||||||||||||||||||||||||||||||||||||||||\n|||||||||||||||||||||||||||||||||||||||||\n"
    ,  print M
    ,  term_to_string T S, print S
    ,  print "|||||||||||||||||||||||||||||||||||||||||\n|||||||||||||||||||||||||||||||||||||||||\n"
    .
 

isa Term TY IE :-
spy    (of Term TY' IE),
spy    (conv TY' TY).
 

of X Y _ :-  locDecl X Y .


tauequ A A T H'
    :- interp_isa A T Ai
    ,  reflu T H
    ,  H' = H Ai
    .
tauequ A B T Hi
    :- spy(locDecl H (propEq T' A B)), !
    ,  spy(interp_isa H (propEq T A B) Hi)
    .

tauequ A B T Hi
    :- (locDecl H (propEq T' B A))
    ,  spy(interp_isa H (propEq T B A) Hi')
    ,  spy (symmu T Q)
    ,  Hi = Q Hi'
    .



tau A A (x \ x) :- !.

tau_trasp A A (x\y\h\ h) :- !.


%interpuce X:_ext T in un Xi di tipi Ti
interp_isa X T Xi 
        :- spy(of X T_inf ext)
        ,  spy(interp X Xi')
        ,  spy(tau T_inf T F)
        ,  spy(Xi = F Xi')
        .

locDecl (k_propId Te) (forall T t1\ forall T t1'\ 
        implies (E t1 t1') (forall T t2\ forall T t2'\ 
                implies (E t2 t2') (implies (E t1 t2) (E t1' t2'))) )
                :- interp Te T
                ,  equ Te E
                .

 
symmu T (x\ fixMe "prova di symmetria").



% interp è molti-a-uno (e->i) nei tipi
% il tipo intensionale può variare per lo stesso elemento estensionale


% supponiamo che conv X Y per poter usare tauequ X Y H
%       H è la prova che i interpotti siano uguali nel loro setoide


