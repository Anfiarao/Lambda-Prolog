%-- non contextual, non reflexive, maybe transitive closure
%-- hstep A B
%---- non contextual, transitive, reflexive normal form
%-- hnf A B
%---- contextual, non reflexive, maybe transitive closure
%-- dstep A B

/* UNITYPED COMPUTATIONAL PREDICATES */
type hstep, dstep, hnf, nf, conv A -> A -> prop.

/*MTT PREDICATES*/
kind mttTerm,               mttType, mttKind, mttLevel type.
type ext, int               mttLevel.
type col, set, propc, props mttKind.
%type s, c       mttSetCol.
%type s, p       mttSetProp.
%type sort       mttSetCol -> mttSetProp -> mttKind.

type locDecl            mttTerm -> mttType -> prop.
type locDeclType        mttType -> mttKind -> prop.
type isType,            mttType -> mttKind -> mttLevel -> prop.
type of, isa            mttTerm -> mttType -> mttLevel -> prop.

type locDef         mttTerm -> mttType -> mttTerm -> prop.

type forall mttType -> (mttTerm -> mttType) -> mttType.


hstep X N :- locDef X T M , conv M N.
hnf A B :- hstep A C, !, hnf C B.
hnf A A.
dstep A B :- hstep A B.
nf A B :- dstep A C, !, nf C B.
nf A A.
conv A A :- ! .
conv A B :- nf A C, nf B C.

isType A col IE  :- isType A set   IE.
isType A col IE  :- isType A propc  IE.
isType A set IE  :- isType A props IE.
isType A propc IE :- isType A props IE.

isType A KIND IE :- locDeclType A KIND .

isa Term TY IE :-
    of Term TY' IE,
    conv TY TY'.


of X Y ext :- locDecl X Y .
isType X Y ext :- locDeclType X Y.

%tau Tipo_di_partenza Tipo_di_arrivo Input Output :- fail.

tau' TipoExt ElementoExt Output :-
    trad ElementoExt ElementoInt,
    trad TipoExt TipoInt,
    of ElementoInt Ty int,
    tau Ty TipoInt ElementoInt Output.






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/*
isType (forall B C) propc ext :-
        (pi x\ locDecl x B => isType (C x) propc ext)
    .


*/

%isType A Sort IE
%of X A IE
%locDef X A M IE



%Is this ever needed?
%trad (of Aa AA ext)
%     (of(tau A_inferred (TradAA) (TradAa) )
%        (TradAA)
%        int
%     ) :-
%     (trad AA TradAA),
%     (trad Aa TradAa),
%     of (TradAa) A_inferred int.


% [NOTAZIONI]
%   X Xx indicano tipo ed elemento
%   of elemento tipo IE
%   isType tipo Kind IE
%

/*
isType (implies B C) prop ext :-
        isType B prop ext
    ,   isType C prop ext
    .
*/
/*
isType (propEq TypeC C1 C2) propc ext:-
       isType TypeC col ext
    ,   print "-.-.-.-." , println TypeC
    ,   spy (of C1 TypeC ext)
    ,   println "--first-spy-done"
    ,   spy (of C2 TypeC ext)
    .
*/