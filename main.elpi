%-- non contextual, non reflexive, maybe transitive closure
%-- hstep A B
%---- non contextual, transitive, reflexive normal form
%-- hnf A B
%---- contextual, non reflexive, maybe transitive closure
%-- dstep A B

/* UNITYPED COMPUTATIONAL PREDICATES */
type hstep, dconv, hnf,  conv A -> A -> prop. 

/*MTT PREDICATES*/
kind mttTerm,               mttType, mttKind, mttLevel type.
type ext, int               mttLevel.
type col, set, propc, props mttKind.
%type s, c       mttSetCol.
%type s, p       mttSetProp.
%type sort       mttSetCol -> mttSetProp -> mttKind.

type locDecl            mttTerm -> mttType -> prop.
type locDeclType        mttType -> mttKind -> prop.
type isType             mttType -> mttKind -> mttLevel -> prop.
type of, isa            mttTerm -> mttType -> mttLevel -> prop.

type locDef         mttTerm -> mttType -> mttTerm -> prop.

type forall mttType -> (mttTerm -> mttType) -> mttType.

 
%hstep X N :- locDef X T M , conv M N.

hnf A B :- hstep A C, !, hnf C B.
hnf A A.

%dstep A B :- spy(hstep A B).
%nf A B :- spy (dstep A C), !, spy(nf C B). %con le regole di eq dstep è diventata riflessiva, 
%nf A A.                         % ho aggiunto il not in eq.elpi per evitare che ciò accada

conv A A :- ! .
conv A B :- spy(locDecl _ (propEq _ A B) ).
conv A B :- spy(hnf A A'), spy( hnf B B'), spy( dconv A' B').

dconv A A :- !.

pts_leq A A.
pts_leq props set.
pts_leq props col.
pts_leq props propc.
pts_leq set col.
pts_leq propc col.


pts_fun A B set:- pts_leq A set, pts_leq B set, !.
pts_fun _ _ col.

pts_for A props props :- pts_leq A set, !.
pts_for _ _ propc. 


%isType A KIND IE :- locDeclType A KIND .

isaT Type Kind IE :-
spy ( isType Type Kind' IE),
spy  (pts_leq  Kind' Kind).



isa Term TY IE :-
spy    (of Term TY' IE),
spy    (conv TY' TY).
 

of X Y _ :-  locDecl X Y .
isType X Y _ :- locDeclType X Y.










































%tau Tipo_di_partenza Tipo_di_arrivo Input Output :- fail.
/*
tau' TipoExt ElementoExt Output :-
    trad ElementoExt ElementoInt,
    trad TipoExt TipoInt,
    of ElementoInt Ty int,
    tau Ty TipoInt ElementoInt Output.
*/





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/*
isType (forall B C) propc ext :-
        (pi x\ locDecl x B => isType (C x) propc ext)
    .


*/

%isType A Sort IE
%of X A IE
%locDef X A M IE



%Is this ever needed?
%trad (of Aa AA ext)
%     (of(tau A_inferred (TradAA) (TradAa) )
%        (TradAA)
%        int
%     ) :-
%     (trad AA TradAA),
%     (trad Aa TradAa),
%     of (TradAa) A_inferred int.


% [NOTAZIONI]
%   X Xx indicano tipo ed elemento
%   of elemento tipo IE
%   isType tipo Kind IE
%

/*
isType (implies B C) prop ext :-
        isType B prop ext
    ,   isType C prop ext
    .
*/
/*
isType (propEq TypeC C1 C2) propc ext:-
       isType TypeC col ext
    ,   print "-.-.-.-." , println TypeC
    ,   spy (of C1 TypeC ext)
    ,   println "--first-spy-done"
    ,   spy (of C2 TypeC ext)
    .
*/


%dstep A B :- locDecl X _, !, fail.
%hstep A B :- locDecl X _, !, fail.
