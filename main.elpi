bracket Pre G Post :- print Pre, term_to_string G S, print S, print Post.
announce G :- bracket ">>" G "\n", fail.
spy G :- (bracket "[Entering " G "\n", G, bracket "]Success  " G "\n";
          bracket "]Leaving  " G "\n",  fail).

load_library [] GOAL :- GOAL.
load_library [ddd NAME BODY | TAIL ] GOAL :-
 of int BODY TYPE,
 defs NAME BODY TYPE => load_library TAIL GOAL.


hnf A B :- announce (hnf A B).
hstep A B :- announce (hstep A B).
dstep A B :- announce (dstep A B).
nf A B :- announce (nf A B).
conv A B :- announce (conv A B).
of IE A B :- announce (of IE A B).

isType K A :- announce (isType K A).
isa IE BB B :- announce (isa IE BB B).
conv A B :- announce (conv A B).




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% non contextual, non reflexive, maybe transitive closure
% hstep A B

% non contextual, transitive, reflexive normal form
hnf A B :- hstep A C, !, hnf C B.
hnf A A.
% contextual, non reflexive, maybe transitive closure
dstep A B :- hstep A B.

% contextual, transitive, reflexive normal form
nf A B :- dstep A C, !, nf C B.
nf A A.

conv A B :- nf A C, nf B C.



isa IE Term TY :- 
    of IE Term TY', 
    conv TY TY'.


isType K T :- nf T T', isType K T'.

isType col  A  :- isType set   A.
isType col  A  :- isType prop  A.
isType prop A  :- isType propS A.
isType set  A  :- isType propS A.





trad (of ext Aa AA) 
     (of int
        (tau A_inferred (TradAA) (TradAa) )
        (TradAA) 
     ) :- 
     (trad AA TradAA), 
     (trad Aa TradAa), 
     of (TradAa) A_inferred. 

trad (isType A Ty) (isType TradA Ty)
    :- trad A TradA.

tau Tipo_di_partenza Tipo_di_arrivo Input Output :- fail.
tau' TipoExt ElementoExt Output :- 
    trad TipoExt TipoInt,
    trad ElementoExt ElementoInt,
    of int ElementoInt Ty,
    tau Ty TipoInt ElementoInt Output.

accumulate calc_simpleSets.
accumulate calc_colSigma.
accumulate calc_nat.    
accumulate calc_setSum.
accumulate calc_setPi.
