accumulate debug.



accumulate main.

accumulate calc/Eq.
accumulate calc/implies.
accumulate calc/setPi.

accumulate calc/singleton.

accumulate calc/forall.

testB  :- pi X\ pi Y\ (locDecl _ (propEq singleton X Y) => spy(conv X Y)). 



testC
 :- spy( isType (
        forall singleton x\
        forall (fun (propEq singleton star star) singleton) f\
        ( implies (propEq singleton star x)
            (propEq singleton 
                    (fun_app f (eqId singleton star)) 
                    (fun_app f (eqId singleton star)) 
            )
        )
        ) col ext).

testA Q1 Q2 :- 
 (pi x\ 
   pi y\ 
    pi l\ 
     pi f\ pi h\ 
      locDecl x singleton =>
       locDecl y singleton =>
        locDecl l (propEq singleton x x) =>
         locDecl f (fun (propEq singleton y y) singleton) =>
          locDecl h (propEq singleton x y) =>
           ( 
            %hnf (fun_app f l) (Q f l)
         %spy   (of  (fun_app f l) (Q1 x y l h f) ext)
    spy     (dstep  x (Q1 x y l h f))
    %spy     (conv  (propEq singleton x x) (propEq singleton y y) ext)
    %spy     (nf (propEq singleton x x) (Q1 x y l h f))
            %isa f (fun (Q1 x y l h f)(Q2 x y l h f) )ext
            %isa l (Q1 x y l h f) ext
           
           )
           ).



















































/*
%           
testExt
    :-  Dom = singleton
    ,   println Dom
    ,   Long = (
        forall Dom x\
         forall Dom y\
          forall (propEq Dom x x) l\
           forall (setPi (propEq Dom y y) z\ Dom) f\
            implies (propEq Dom x y) (propEq Dom (apply f l) (apply f l))
            )
    ,   println Long
    ,   isType Long prop ext
    .
 

testshort Q :-
        Dom = singleton
    ,   Short = (
         forall Dom y\
          forall singleton l\
           forall (setPi singleton z\Dom) f\
            (propEq Dom (apply f l) (apply f l))
            )
    ,   isType Short Q ext
    .

test sostituzione_diretta :- locDecl h (propEq singleton qwe star) => dstep qwe A.
test sostituzione_indiretta :- (dstep a b :- locDef _ (propEq _ a b) _ ) .

spy_depth N :- sigma L\ spy_indent L , pi L'\ spy_indent L' => sublist L' L.
spy_add [0|LL] :- sigma L\ spy_indent L , pi L'\ spy_indent L' => sublist L' L.

*/