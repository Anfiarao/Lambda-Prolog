%include calc.
bracket Pre G Post :- print Pre, term_to_string G S, print S, print Post.
announce G :- bracket ">>" G "\n", fail.
spy G :- (bracket "[Entering " G "\n", G, bracket "]Success  " G "\n";
          bracket "]Leaving  " G "\n",  fail).
success.
%printt A :- term_to_string A S, print"]>-+-+-+-+[> ", print S, print "\n".

nf A B  :- announce ( nf A B).
%bnf A B :- announce (bnf A B).
%printt T:- announce (printt T) ; success.
%natint A B :- announce ( natint A B).
%intnat A B :- announce ( intnat A B).

conv A B :- nf A B ; (nf A C, nf B C).
nf A A :- (bnf A A), ! .
nf A B :- (bnf A C), nf C B .

%bnf X XX :- defs X XX _.
of X Y :- defs X _ Y.

conv A B :- nf A B ; (nf A C, nf B C).

load_library [] GOAL :- GOAL.
load_library [ddd NAME BODY | TAIL ] GOAL :-
 of BODY TYPE,
 defs NAME BODY TYPE => load_library TAIL GOAL.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


isType set (setPi A B) :-    % SET FORMATION
    isType set A, 
    pi x\ of x A => 
        bnf x x => 
            isType set (B x).


of (lambda B F) (setPi B C) :-  % ELEMENT FORMATION
    isType set (setPi B C), 
        pi x\ of x B => bnf x x => of (F x) (C x).

of (app Lam X)  (CX) :- % ELEMENT ELIMINATION
    of Lam (setPi B C),
    of X B,
    CX = C X.


bnf ( app (lambda B F) Bb) (F Bb) :- of Bb B, of (lambda B F) (setPi B C). 



