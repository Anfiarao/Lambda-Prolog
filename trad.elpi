
% trad è uno-a-molto nei tipi
% il tipo intensionale può variare per lo stesso elemento estensionale



trad (forall B C) (forall B' C') :-
        spy (trad B B'),
        spy (pi x\ pi x' \ trad x x' => locDecl x B => locDecl x' B' => trad (C x )(C'  x')).

trad singleton singleton.
trad star star.

trad (implies B C) (forall B' C') 
    :- trad B B'
    ,  spy(pi x\ pi x'\ 
        (  trad x x'
        ,  locDecl x B
        ,  locDecl x' B') 
            =>  trad C (C' x')
    )
    .


trad (propEq A Aa1 Aa2) R 
    :- spy(equ A EquA)
    ,  spy(trad_isa Aa1 A Aa1')
    ,  spy(trad_isa Aa2 A Aa2')
    ,  spy(R = (EquA Aa1' Aa2'))
    .

trad (eqId  A Aa)  T
    :- spy(reflu A ReflA)
    ,  spy(trad Aa Aa')
    ,  T = (ReflA Aa') 
    .
reflu (propEq A Aa Aa) (id A Aa).

equ singleton (x\ y\ propId singleton x y).
reflu singleton (x\ id singleton x).

equ (propEq A Aa1 Aa2) (_\ _\ (propId singleton star star)).



pippo A A x \ x.

%traduce X:_ext T in un Xi di tipi Ti
trad_isa X T Xi 
        :- spy(of X T_inf ext)
        ,  spy(trad X Xi')
        ,  spy(pippo T_inf T F)
        ,  spy(Xi = F Xi')
        .
pippo (propEq T_ T1 T2) (propEq T T1' T2') (F)
    :- spy(pippoequ T1 T1' T F1)
    ,  spy(pippoequ T2 T2' T F2)
    ,  spy(trad_isa T1 T T1i)
    ,  spy(trad_isa T2 T T2i)
    ,  spy(trad_isa T1' T T1i')
    ,  spy(trad_isa T2' T T2i')
    ,  spy(trad T Ti)
    ,  F = x\ impl_app ( 
                impl_app ( 
                 forall_app ( 
                  forall_app ( 
                   impl_app ( 
                    forall_app ( 
                     forall_app (k_propId Ti) T1i) T1i') F1) T2i) T2i') F2) x
    .

% supponiamo che conv X Y per poter usare pippoequ X Y H
%       H è la prova che i tradotti siano uguali nel loro setoide

pippoequ A A T (id Ti Ai )
    :- trad_isa A T Ai
    ,  trad T Ti
    .
pippoequ A B T Hi
    :- (locDecl H (propEq T' A B)), !
    ,  spy(trad_isa H (propEq T A B) Hi)
    .

pippoequ A B T Hi
    :- (locDecl H (propEq T' B A))
    ,  spy(trad_isa H (propEq T B A) Hi')
    ,  spy (symmu T Q)
    ,  Hi = Q Hi'
    .

symmu T (x\ fixMe "prova di symmetria").




locDecl (k_propId T) (forall T t1\ forall T t1'\ 
        implies (propId T t1 t1') (forall T t2\ forall T t2'\ 
                implies (propId T t2 t2') (implies (propId T t1 t2) (propId T t1' t2'))) ).
