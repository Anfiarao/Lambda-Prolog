
trad (forall B C) (forall B' C') :-
        spy (trad B B'),
        spy (pi x\ pi x' \ trad x x' => locDecl x B => locDecl x' B' => trad (C x )(C'  x')).

trad singleton singleton.
trad star star.
trad (setSum A B) (setSum Ai Bi) :- trad A Ai, trad B Bi.
trad (inl A' B Aa) (inl Ai' Bi Aai') 
        :- trad A' Ai'
        ,  trad B Bi
        ,  of Aa A ext
        ,  pippo A A' PIPPO
        ,  trad Aa Aai
        ,  Aai' = PIPPO Aai
        .

pippo (setSum A B) (setSum A' B') F 
        :- (pippo A A' FA)
        ,  (pippo B B' FB)
        ,  F = (z \elim_setSum 
                 (_ \ setSum A' B') 
                 z 
                 (x \ inl A' B' (FA x)) 
                 (y \ inr A' B' (FB y)))
        .

equ (setSum A B) P 
        :- isType A _ ext , equ A PA
        ,  isType B _ ext , equ B PB
        ,  P = (z\ z'\ or 
               (exist (A) (x \ 
                exist (A) (x'\ and (and 
                        (propId (setSum A B) z  (inl A B x)) 
                        (propId (setSum A B) z' (inl A B x')) ) 
                        (PA x x')
                ))) 
               (exist (B) (x \ 
                exist (B) (x'\ and (and 
                        (propId (setSum A B) z  (inr A B x)) 
                        (propId (setSum A B) z' (inr A B x')) ) 
                        (PB x x')
                )))
        )
        .
pippoequ (inl A B X) (inl A B X') H 
        :- pippoequ X X' K
        ,  trad X Xi
        ,  trad X' Xi'
        ,  of X Ae ext
        ,  pippo Ae A PIA
        ,  pippo Ae' A PIA'
        ,  equ A PA
        ,  equ B PB
        ,  inl_or (exist (A) (x \ 
                   exist (A) (x'\ and (and 
                         (propId (setSum A B) (inl A B (PIA Xi))  (inl A B x)) 
                         (propId (setSum A B) (inl A B (PIA' Xi')) (inl A B x')) ) 
                         (PA x x')
                   ))) 
                  (exist (B) (x \ 
                   exist (B) (x'\ and (and 
                         (propId (setSum A B) (inr A B (PIA Xi))  (inr A B x)) 
                         (propId (setSum A B) (inr A B (PIA'Xi')) (inr A B x')) ) 
                         (PB x x')
                   ))) 
                  (pair_exist (PIA Xi) (pair_exist (PIA' Xi') 
                   pair_and (pair_and 
                        (id (setSum A B) (inl A B (PIA Xi) )) 
                        (id (setSum A B) (inl A B (PIA' Xi') ))) 
                        (K)
                  ))
        .

trad (implies B C) (forall B' C') 
    :- trad B B'
    ,  spy(pi x\ pi x'\ 
        (  trad x x'
        ,  locDecl x B
        ,  locDecl x' B') 
            =>  trad C (C' x')
    )
    .


trad (propEq A Aa1 Aa2) R 
    :- spy(equ  A EquA)
    ,  spy(trad Aa1 Aa1')
    ,  spy (trad Aa2 Aa2')
    ,  spy(R = (EquA Aa1' Aa2'))
    .

trad (eqId  A Aa)  T
    :- spy(reflu A ReflA)
    ,  spy(trad Aa Aa')
    ,  T = (ReflA Aa') 
    .
reflu (propEq A Aa Aa) (id A Aa).

equ singleton (x\ y\ propId singleton x y).
reflu singleton (x\ id singleton x).

equ (propEq A Aa1 Aa2) (_\ _\ (propId singleton star star)).



pippo A A x \ x.

pippo (propEq T T1 T2) (propEq T T1' T2') (F)
    :- spy(pippoequ T1 T1' F1)
    ,  spy(pippoequ T2 T2' F2)
    ,  spy(trad T1 T1i)
    ,  spy(trad T2 T2i)
    ,  spy(trad T1' T1i')
    ,  spy(trad T2' T2i')
    ,  spy(trad T Ti)
    ,  F = x\ impl_app ( 
                impl_app ( 
                 forall_app ( 
                  forall_app ( 
                   impl_app ( 
                    forall_app ( 
                     forall_app (k_propId Ti) T1i) T1i') F1) T2i) T2i') F2) x
    .

% supponiamo che conv X Y per poter usare pippoequ X Y H
%       H Ã¨ la prova che i tradotti siano uguali nel loro setoide

pippoequ A A (id T' A' )
    :- trad A A'
    ,  of A' T' int
    .
pippoequ A B H'
    :- spy(locDecl H (propEq _ A B)), !
    ,  trad H H'
    .
pippoequ A B ( H'')
    :- spy(locDecl H (propEq T B A))
    ,  trad H H'
    ,  spy (symmu T Q)
    ,  H'' = Q H'
    .

symmu T (x\ fixMEEEEEE).





locDecl (k_propId T) (forall T t1\ forall T t1'\ 
        implies (propId T t1 t1') (forall T t2\ forall T t2'\ 
                implies (propId T t2 t2') (implies (propId T t1 t2) (propId T t1' t2'))) ).
